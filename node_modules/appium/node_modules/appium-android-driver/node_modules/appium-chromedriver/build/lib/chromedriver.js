require('source-map-support').install();

'use strict';

var _get = require('babel-runtime/helpers/get')['default'];

var _inherits = require('babel-runtime/helpers/inherits')['default'];

var _createClass = require('babel-runtime/helpers/create-class')['default'];

var _classCallCheck = require('babel-runtime/helpers/class-call-check')['default'];

var _regeneratorRuntime = require('babel-runtime/regenerator')['default'];

var _interopRequireDefault = require('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _events = require('events');

var _events2 = _interopRequireDefault(_events);

var _appiumJsonwpProxy = require('appium-jsonwp-proxy');

var _appiumJsonwpProxy2 = _interopRequireDefault(_appiumJsonwpProxy);

var _appiumLogger = require('appium-logger');

var _child_process = require('child_process');

var _child_process2 = _interopRequireDefault(_child_process);

var _appiumSupport = require('appium-support');

var _asyncbox = require('asyncbox');

var _teen_process = require('teen_process');

var _bluebird = require('bluebird');

var _bluebird2 = _interopRequireDefault(_bluebird);

var _install = require('./install');

var log = (0, _appiumLogger.getLogger)('Chromedriver');

var DEFAULT_HOST = '127.0.0.1';
var DEFAULT_PORT = 9515;

var Chromedriver = (function (_events$EventEmitter) {
  _inherits(Chromedriver, _events$EventEmitter);

  function Chromedriver() {
    var args = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

    _classCallCheck(this, Chromedriver);

    var host = args.host;
    var port = args.port;
    var executable = args.executable;
    var cmdArgs = args.cmdArgs;
    var adbPort = args.adbPort;

    _get(Object.getPrototypeOf(Chromedriver.prototype), 'constructor', this).call(this);
    this.proxyHost = host || DEFAULT_HOST;
    this.proxyPort = port || DEFAULT_PORT;
    this.adbPort = adbPort;
    this.cmdArgs = cmdArgs;
    this.proc = null;
    this.chromedriver = executable;
    this.executableVerified = false;
    this.state = Chromedriver.STATE_STOPPED;
    this.jwproxy = new _appiumJsonwpProxy2['default']({ server: this.proxyHost, port: this.proxyPort });
  }

  _createClass(Chromedriver, [{
    key: 'initChromedriverPath',
    value: function initChromedriverPath() {
      var binPath;
      return _regeneratorRuntime.async(function initChromedriverPath$(context$2$0) {
        while (1) switch (context$2$0.prev = context$2$0.next) {
          case 0:
            if (!this.executableVerified) {
              context$2$0.next = 2;
              break;
            }

            return context$2$0.abrupt('return');

          case 2:
            context$2$0.t0 = this.chromedriver;

            if (context$2$0.t0) {
              context$2$0.next = 7;
              break;
            }

            context$2$0.next = 6;
            return _regeneratorRuntime.awrap((0, _install.getChromedriverBinaryPath)());

          case 6:
            context$2$0.t0 = context$2$0.sent;

          case 7:
            binPath = context$2$0.t0;
            context$2$0.next = 10;
            return _regeneratorRuntime.awrap(_appiumSupport.fs.exists(binPath));

          case 10:
            if (context$2$0.sent) {
              context$2$0.next = 12;
              break;
            }

            throw new Error('Trying to use a chromedriver binary at the path ' + (binPath + ', but it doesn\'t exist!'));

          case 12:
            this.chromedriver = binPath;
            this.executableVerified = true;
            log.info('Set chromedriver binary as: ' + this.chromedriver);

          case 15:
          case 'end':
            return context$2$0.stop();
        }
      }, null, this);
    }
  }, {
    key: 'start',
    value: function start(caps) {
      var emitStartingState = arguments.length <= 1 || arguments[1] === undefined ? true : arguments[1];
      var processIsAlive, args, startDetector;
      return _regeneratorRuntime.async(function start$(context$2$0) {
        var _this = this;

        while (1) switch (context$2$0.prev = context$2$0.next) {
          case 0:
            this.capabilities = caps;
            if (emitStartingState) {
              this.changeState(Chromedriver.STATE_STARTING);
            }
            processIsAlive = true;
            args = ["--url-base=wd/hub", '--port=' + this.proxyPort];

            if (this.adbPort) {
              args = args.concat(['--adb-port=' + this.adbPort]);
            }
            if (this.cmdArgs) {
              args = args.concat(this.cmdArgs);
            }

            // what are the process stdout/stderr conditions wherein we know that
            // the process has started to our satisfaction?

            startDetector = function startDetector(stdout) {
              return stdout.indexOf('Starting ') === 0;
            };

            context$2$0.prev = 7;
            context$2$0.next = 10;
            return _regeneratorRuntime.awrap(this.initChromedriverPath());

          case 10:
            context$2$0.next = 12;
            return _regeneratorRuntime.awrap(this.killAll());

          case 12:
            // set up our subprocess object
            this.proc = new _teen_process.SubProcess(this.chromedriver, args);

            // handle log output
            this.proc.on('output', function (stdout, stderr) {
              if (stdout) {
                log.info('[STDOUT] ' + stdout.trim());
              }
              if (stderr) {
                log.info('[STDERR] ' + stderr.trim());
              }
            });

            // handle out-of-bound exit by simply emitting a stopped state
            this.proc.on('exit', function (code, signal) {
              processIsAlive = false;
              if (_this.state !== Chromedriver.STATE_STOPPED && _this.state !== Chromedriver.STATE_STOPPING && _this.state !== Chromedriver.STATE_RESTARTING) {
                var msg = 'Chromedriver exited unexpectedly with code ' + code + ', ' + ('signal ' + signal);
                log.error(msg);
                _this.changeState(Chromedriver.STATE_STOPPED);
              }
            });
            log.info('Spawning chromedriver with: ' + this.chromedriver + ' ' + ('' + args.join(' ')));
            // start subproc and wait for startDetector
            context$2$0.next = 18;
            return _regeneratorRuntime.awrap(this.proc.start(startDetector));

          case 18:
            context$2$0.next = 20;
            return _regeneratorRuntime.awrap(this.waitForOnline());

          case 20:
            context$2$0.next = 22;
            return _regeneratorRuntime.awrap(this.startSession());

          case 22:
            context$2$0.next = 31;
            break;

          case 24:
            context$2$0.prev = 24;
            context$2$0.t0 = context$2$0['catch'](7);

            this.emit(Chromedriver.EVENT_ERROR, context$2$0.t0);
            // just because we had an error doesn't mean the chromedriver process
            // finished; we should clean up if necessary

            if (!processIsAlive) {
              context$2$0.next = 30;
              break;
            }

            context$2$0.next = 30;
            return _regeneratorRuntime.awrap(this.proc.stop());

          case 30:
            log.errorAndThrow(context$2$0.t0);

          case 31:
          case 'end':
            return context$2$0.stop();
        }
      }, null, this, [[7, 24]]);
    }
  }, {
    key: 'sessionId',
    value: function sessionId() {
      if (this.state !== Chromedriver.STATE_ONLINE) {
        return null;
      }

      return this.jwproxy.sessionId;
    }
  }, {
    key: 'restart',
    value: function restart() {
      return _regeneratorRuntime.async(function restart$(context$2$0) {
        while (1) switch (context$2$0.prev = context$2$0.next) {
          case 0:
            log.info("Restarting chromedriver");

            if (!(this.state !== Chromedriver.STATE_ONLINE)) {
              context$2$0.next = 3;
              break;
            }

            throw new Error("Can't restart when we're not online");

          case 3:
            this.changeState(Chromedriver.STATE_RESTARTING);
            context$2$0.next = 6;
            return _regeneratorRuntime.awrap(this.stop(false));

          case 6:
            context$2$0.next = 8;
            return _regeneratorRuntime.awrap(this.start(this.capabilities, false));

          case 8:
          case 'end':
            return context$2$0.stop();
        }
      }, null, this);
    }
  }, {
    key: '_statePromise',
    value: function _statePromise() {
      var _this2 = this;

      var state = arguments.length <= 0 || arguments[0] === undefined ? null : arguments[0];

      return new _bluebird2['default'](function (resolve) {
        var listener = function listener(msg) {
          if (state === null || msg.state === state) {
            resolve(msg.state);
            _this2.removeListener(Chromedriver.EVENT_CHANGED, listener);
          }
        };
        _this2.on(Chromedriver.EVENT_CHANGED, listener);
      });
    }
  }, {
    key: 'waitForOnline',
    value: function waitForOnline() {
      var chromedriverStopped;
      return _regeneratorRuntime.async(function waitForOnline$(context$2$0) {
        var _this3 = this;

        while (1) switch (context$2$0.prev = context$2$0.next) {
          case 0:
            chromedriverStopped = false;
            context$2$0.next = 3;
            return _regeneratorRuntime.awrap((0, _asyncbox.retryInterval)(20, 200, function callee$2$0() {
              return _regeneratorRuntime.async(function callee$2$0$(context$3$0) {
                while (1) switch (context$3$0.prev = context$3$0.next) {
                  case 0:
                    if (!(this.state === Chromedriver.STATE_STOPPED)) {
                      context$3$0.next = 3;
                      break;
                    }

                    // we are either stopped or stopping, so something went wrong
                    chromedriverStopped = true;
                    return context$3$0.abrupt('return');

                  case 3:
                    context$3$0.next = 5;
                    return _regeneratorRuntime.awrap(this.getStatus());

                  case 5:
                  case 'end':
                    return context$3$0.stop();
                }
              }, null, _this3);
            }));

          case 3:
            if (!chromedriverStopped) {
              context$2$0.next = 5;
              break;
            }

            throw new Error('ChromeDriver crashed during startup.');

          case 5:
          case 'end':
            return context$2$0.stop();
        }
      }, null, this);
    }
  }, {
    key: 'getStatus',
    value: function getStatus() {
      return _regeneratorRuntime.async(function getStatus$(context$2$0) {
        while (1) switch (context$2$0.prev = context$2$0.next) {
          case 0:
            context$2$0.next = 2;
            return _regeneratorRuntime.awrap(this.jwproxy.command('/status', 'GET'));

          case 2:
            return context$2$0.abrupt('return', context$2$0.sent);

          case 3:
          case 'end':
            return context$2$0.stop();
        }
      }, null, this);
    }
  }, {
    key: 'startSession',
    value: function startSession() {
      return _regeneratorRuntime.async(function startSession$(context$2$0) {
        while (1) switch (context$2$0.prev = context$2$0.next) {
          case 0:
            context$2$0.next = 2;
            return _regeneratorRuntime.awrap((0, _asyncbox.retryInterval)(4, 200, this.jwproxy.command.bind(this.jwproxy), '/session', 'POST', { desiredCapabilities: this.capabilities }));

          case 2:
            this.changeState(Chromedriver.STATE_ONLINE);

          case 3:
          case 'end':
            return context$2$0.stop();
        }
      }, null, this);
    }
  }, {
    key: 'stop',
    value: function stop() {
      var emitStates = arguments.length <= 0 || arguments[0] === undefined ? true : arguments[0];
      return _regeneratorRuntime.async(function stop$(context$2$0) {
        while (1) switch (context$2$0.prev = context$2$0.next) {
          case 0:
            if (emitStates) {
              this.changeState(Chromedriver.STATE_STOPPING);
            }
            context$2$0.prev = 1;
            context$2$0.next = 4;
            return _regeneratorRuntime.awrap(this.jwproxy.command('', 'DELETE'));

          case 4:
            context$2$0.next = 6;
            return _regeneratorRuntime.awrap(this.proc.stop());

          case 6:
            if (emitStates) {
              this.changeState(Chromedriver.STATE_STOPPED);
            }
            context$2$0.next = 12;
            break;

          case 9:
            context$2$0.prev = 9;
            context$2$0.t0 = context$2$0['catch'](1);

            log.error(context$2$0.t0);

          case 12:
          case 'end':
            return context$2$0.stop();
        }
      }, null, this, [[1, 9]]);
    }
  }, {
    key: 'changeState',
    value: function changeState(state) {
      this.state = state;
      log.debug('Changed state to \'' + state + '\'');
      this.emit(Chromedriver.EVENT_CHANGED, { state: state });
    }
  }, {
    key: 'sendCommand',
    value: function sendCommand(url, method, body) {
      return _regeneratorRuntime.async(function sendCommand$(context$2$0) {
        while (1) switch (context$2$0.prev = context$2$0.next) {
          case 0:
            context$2$0.next = 2;
            return _regeneratorRuntime.awrap(this.jwproxy.command(url, method, body));

          case 2:
            return context$2$0.abrupt('return', context$2$0.sent);

          case 3:
          case 'end':
            return context$2$0.stop();
        }
      }, null, this);
    }
  }, {
    key: 'proxyReq',
    value: function proxyReq(req, res) {
      return _regeneratorRuntime.async(function proxyReq$(context$2$0) {
        while (1) switch (context$2$0.prev = context$2$0.next) {
          case 0:
            context$2$0.next = 2;
            return _regeneratorRuntime.awrap(this.jwproxy.proxyReqRes(req, res));

          case 2:
            return context$2$0.abrupt('return', context$2$0.sent);

          case 3:
          case 'end':
            return context$2$0.stop();
        }
      }, null, this);
    }
  }, {
    key: 'killAll',
    value: function killAll() {
      var cmd;
      return _regeneratorRuntime.async(function killAll$(context$2$0) {
        while (1) switch (context$2$0.prev = context$2$0.next) {
          case 0:
            cmd = undefined;

            if (_appiumSupport.system.isWindows()) {
              // js hint cannot handle backticks, even escaped, within template literals
              cmd = "FOR /F \"usebackq tokens=5\" %a in (`netstat -nao ^| " + "findstr /R /C:\"" + this.proxyPort + " \"`) do (" + "FOR /F \"usebackq\" %b in (`TASKLIST /FI \"PID eq %a\" ^| " + "findstr /I chromedriver.exe`) do (IF NOT %b==\"\" TASKKILL " + "/F /PID %a))";
            } else {
              cmd = 'ps -ef | grep ' + this.chromedriver + ' | grep -v grep |' + ('grep -e \'--port=' + this.proxyPort + '\\(\\s.*\\)\\?$\' | awk ') + '\'{ print $2 }\' | xargs kill -15';
            }
            log.info('Killing any old chromedrivers, running: ' + cmd);
            context$2$0.prev = 3;
            context$2$0.next = 6;
            return _regeneratorRuntime.awrap(_bluebird2['default'].promisify(_child_process2['default'].exec)(cmd));

          case 6:
            log.info("Successfully cleaned up old chromedrivers");
            context$2$0.next = 12;
            break;

          case 9:
            context$2$0.prev = 9;
            context$2$0.t0 = context$2$0['catch'](3);

            log.info("No old chromedrivers seemed to exist");

          case 12:
          case 'end':
            return context$2$0.stop();
        }
      }, null, this, [[3, 9]]);
    }
  }, {
    key: 'hasWorkingWebview',
    value: function hasWorkingWebview() {
      return _regeneratorRuntime.async(function hasWorkingWebview$(context$2$0) {
        while (1) switch (context$2$0.prev = context$2$0.next) {
          case 0:
            context$2$0.prev = 0;
            context$2$0.next = 3;
            return _regeneratorRuntime.awrap(this.jwproxy.command('/url', 'GET'));

          case 3:
            return context$2$0.abrupt('return', true);

          case 6:
            context$2$0.prev = 6;
            context$2$0.t0 = context$2$0['catch'](0);
            return context$2$0.abrupt('return', false);

          case 9:
          case 'end':
            return context$2$0.stop();
        }
      }, null, this, [[0, 6]]);
    }
  }]);

  return Chromedriver;
})(_events2['default'].EventEmitter);

Chromedriver.EVENT_ERROR = 'chromedriver_error';
Chromedriver.EVENT_CHANGED = 'stateChanged';
Chromedriver.STATE_STOPPED = 'stopped';
Chromedriver.STATE_STARTING = 'starting';
Chromedriver.STATE_ONLINE = 'online';
Chromedriver.STATE_STOPPING = 'stopping';
Chromedriver.STATE_RESTARTING = 'restarting';

exports['default'] = Chromedriver;
module.exports = exports['default'];

// we need to make sure that CD hasn't crashed

// retry session start 4 times, sometimes this fails due to adb

// sometimes chromedriver stops automating webviews. this method runs a
// simple command to determine our state, and responds accordingly
//# sourceMappingURL=data:application/json;base64,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RCw2REFBNkQsR0FDN0QsY0FBYyxDQUFDO2FBQ3RCLE1BQU07QUFDTCxpQkFBRyxHQUFHLG1CQUFpQixJQUFJLENBQUMsWUFBWSxnREFDZixJQUFJLENBQUMsU0FBUyw4QkFBeUIsc0NBQ3pCLENBQUM7YUFDekM7QUFDRCxlQUFHLENBQUMsSUFBSSw4Q0FBNEMsR0FBRyxDQUFHLENBQUM7Ozs2Q0FFbkQsQUFBQyxzQkFBRSxTQUFTLENBQUMsMkJBQUcsSUFBSSxDQUFDLENBQUUsR0FBRyxDQUFDOzs7QUFDakMsZUFBRyxDQUFDLElBQUksQ0FBQywyQ0FBMkMsQ0FBQyxDQUFDOzs7Ozs7OztBQUV0RCxlQUFHLENBQUMsSUFBSSxDQUFDLHNDQUFzQyxDQUFDLENBQUM7Ozs7Ozs7S0FFcEQ7OztXQUV1Qjs7Ozs7OzZDQUlkLElBQUksQ0FBQyxPQUFPLENBQUMsT0FBTyxDQUFDLE1BQU0sRUFBRSxLQUFLLENBQUM7OztnREFDbEMsSUFBSTs7Ozs7Z0RBRUosS0FBSzs7Ozs7OztLQUVmOzs7U0FsTkcsWUFBWTtHQUFTLG9CQUFPLFlBQVk7O0FBcU45QyxZQUFZLENBQUMsV0FBVyxHQUFHLG9CQUFvQixDQUFDO0FBQ2hELFlBQVksQ0FBQyxhQUFhLEdBQUcsY0FBYyxDQUFDO0FBQzVDLFlBQVksQ0FBQyxhQUFhLEdBQUcsU0FBUyxDQUFDO0FBQ3ZDLFlBQVksQ0FBQyxjQUFjLEdBQUcsVUFBVSxDQUFDO0FBQ3pDLFlBQVksQ0FBQyxZQUFZLEdBQUcsUUFBUSxDQUFDO0FBQ3JDLFlBQVksQ0FBQyxjQUFjLEdBQUcsVUFBVSxDQUFDO0FBQ3pDLFlBQVksQ0FBQyxnQkFBZ0IsR0FBRyxZQUFZLENBQUM7O3FCQUU5QixZQUFZIiwiZmlsZSI6ImxpYi9jaHJvbWVkcml2ZXIuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyB0cmFuc3BpbGU6bWFpblxuXG5pbXBvcnQgZXZlbnRzIGZyb20gJ2V2ZW50cyc7XG5pbXBvcnQgSldQcm94eSBmcm9tICdhcHBpdW0tanNvbndwLXByb3h5JztcbmltcG9ydCB7IGdldExvZ2dlciB9IGZyb20gJ2FwcGl1bS1sb2dnZXInO1xuaW1wb3J0IGNwIGZyb20gJ2NoaWxkX3Byb2Nlc3MnO1xuaW1wb3J0IHsgc3lzdGVtLCBmcyB9IGZyb20gJ2FwcGl1bS1zdXBwb3J0JztcbmltcG9ydCB7IHJldHJ5SW50ZXJ2YWwgfSBmcm9tICdhc3luY2JveCc7XG5pbXBvcnQgeyBTdWJQcm9jZXNzIH0gZnJvbSAndGVlbl9wcm9jZXNzJztcbmltcG9ydCBCIGZyb20gJ2JsdWViaXJkJztcbmltcG9ydCB7IGdldENocm9tZWRyaXZlckJpbmFyeVBhdGggfSBmcm9tICcuL2luc3RhbGwnO1xuXG5cbmNvbnN0IGxvZyA9IGdldExvZ2dlcignQ2hyb21lZHJpdmVyJyk7XG5cbmNvbnN0IERFRkFVTFRfSE9TVCA9ICcxMjcuMC4wLjEnO1xuY29uc3QgREVGQVVMVF9QT1JUID0gOTUxNTtcbmNsYXNzIENocm9tZWRyaXZlciBleHRlbmRzIGV2ZW50cy5FdmVudEVtaXR0ZXIge1xuICBjb25zdHJ1Y3RvciAoYXJncyA9IHt9KSB7XG4gICAgY29uc3Qge2hvc3QsIHBvcnQsIGV4ZWN1dGFibGUsIGNtZEFyZ3MsIGFkYlBvcnR9ID0gYXJncztcbiAgICBzdXBlcigpO1xuICAgIHRoaXMucHJveHlIb3N0ID0gaG9zdCB8fCBERUZBVUxUX0hPU1Q7XG4gICAgdGhpcy5wcm94eVBvcnQgPSBwb3J0IHx8IERFRkFVTFRfUE9SVDtcbiAgICB0aGlzLmFkYlBvcnQgPSBhZGJQb3J0O1xuICAgIHRoaXMuY21kQXJncyA9IGNtZEFyZ3M7XG4gICAgdGhpcy5wcm9jID0gbnVsbDtcbiAgICB0aGlzLmNocm9tZWRyaXZlciA9IGV4ZWN1dGFibGU7XG4gICAgdGhpcy5leGVjdXRhYmxlVmVyaWZpZWQgPSBmYWxzZTtcbiAgICB0aGlzLnN0YXRlID0gQ2hyb21lZHJpdmVyLlNUQVRFX1NUT1BQRUQ7XG4gICAgdGhpcy5qd3Byb3h5ID0gbmV3IEpXUHJveHkoe3NlcnZlcjogdGhpcy5wcm94eUhvc3QsIHBvcnQ6IHRoaXMucHJveHlQb3J0fSk7XG4gIH1cblxuICBhc3luYyBpbml0Q2hyb21lZHJpdmVyUGF0aCAoKSB7XG4gICAgaWYgKHRoaXMuZXhlY3V0YWJsZVZlcmlmaWVkKSByZXR1cm47XG4gICAgbGV0IGJpblBhdGggPSB0aGlzLmNocm9tZWRyaXZlciB8fCAoYXdhaXQgZ2V0Q2hyb21lZHJpdmVyQmluYXJ5UGF0aCgpKTtcbiAgICBpZiAoIWF3YWl0IGZzLmV4aXN0cyhiaW5QYXRoKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBUcnlpbmcgdG8gdXNlIGEgY2hyb21lZHJpdmVyIGJpbmFyeSBhdCB0aGUgcGF0aCBgICtcbiAgICAgICAgICAgICAgICAgICAgICBgJHtiaW5QYXRofSwgYnV0IGl0IGRvZXNuJ3QgZXhpc3QhYCk7XG4gICAgfVxuICAgIHRoaXMuY2hyb21lZHJpdmVyID0gYmluUGF0aDtcbiAgICB0aGlzLmV4ZWN1dGFibGVWZXJpZmllZCA9IHRydWU7XG4gICAgbG9nLmluZm8oYFNldCBjaHJvbWVkcml2ZXIgYmluYXJ5IGFzOiAke3RoaXMuY2hyb21lZHJpdmVyfWApO1xuICB9XG5cbiAgYXN5bmMgc3RhcnQgKGNhcHMsIGVtaXRTdGFydGluZ1N0YXRlID0gdHJ1ZSkge1xuICAgIHRoaXMuY2FwYWJpbGl0aWVzID0gY2FwcztcbiAgICBpZiAoZW1pdFN0YXJ0aW5nU3RhdGUpIHtcbiAgICAgIHRoaXMuY2hhbmdlU3RhdGUoQ2hyb21lZHJpdmVyLlNUQVRFX1NUQVJUSU5HKTtcbiAgICB9XG4gICAgbGV0IHByb2Nlc3NJc0FsaXZlID0gdHJ1ZTtcbiAgICBsZXQgYXJncyA9IFtcIi0tdXJsLWJhc2U9d2QvaHViXCIsIGAtLXBvcnQ9JHt0aGlzLnByb3h5UG9ydH1gXTtcbiAgICBpZiAodGhpcy5hZGJQb3J0KSB7XG4gICAgICBhcmdzID0gYXJncy5jb25jYXQoW2AtLWFkYi1wb3J0PSR7dGhpcy5hZGJQb3J0fWBdKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuY21kQXJncykge1xuICAgICAgYXJncyA9IGFyZ3MuY29uY2F0KHRoaXMuY21kQXJncyk7XG4gICAgfVxuXG4gICAgLy8gd2hhdCBhcmUgdGhlIHByb2Nlc3Mgc3Rkb3V0L3N0ZGVyciBjb25kaXRpb25zIHdoZXJlaW4gd2Uga25vdyB0aGF0XG4gICAgLy8gdGhlIHByb2Nlc3MgaGFzIHN0YXJ0ZWQgdG8gb3VyIHNhdGlzZmFjdGlvbj9cbiAgICBjb25zdCBzdGFydERldGVjdG9yID0gKHN0ZG91dCkgPT4ge1xuICAgICAgcmV0dXJuIHN0ZG91dC5pbmRleE9mKCdTdGFydGluZyAnKSA9PT0gMDtcbiAgICB9O1xuXG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IHRoaXMuaW5pdENocm9tZWRyaXZlclBhdGgoKTtcbiAgICAgIGF3YWl0IHRoaXMua2lsbEFsbCgpO1xuICAgICAgLy8gc2V0IHVwIG91ciBzdWJwcm9jZXNzIG9iamVjdFxuICAgICAgdGhpcy5wcm9jID0gbmV3IFN1YlByb2Nlc3ModGhpcy5jaHJvbWVkcml2ZXIsIGFyZ3MpO1xuXG4gICAgICAvLyBoYW5kbGUgbG9nIG91dHB1dFxuICAgICAgdGhpcy5wcm9jLm9uKCdvdXRwdXQnLCAoc3Rkb3V0LCBzdGRlcnIpID0+IHtcbiAgICAgICAgaWYgKHN0ZG91dCkge1xuICAgICAgICAgIGxvZy5pbmZvKGBbU1RET1VUXSAke3N0ZG91dC50cmltKCl9YCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0ZGVycikge1xuICAgICAgICAgIGxvZy5pbmZvKGBbU1RERVJSXSAke3N0ZGVyci50cmltKCl9YCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICAvLyBoYW5kbGUgb3V0LW9mLWJvdW5kIGV4aXQgYnkgc2ltcGx5IGVtaXR0aW5nIGEgc3RvcHBlZCBzdGF0ZVxuICAgICAgdGhpcy5wcm9jLm9uKCdleGl0JywgKGNvZGUsIHNpZ25hbCkgPT4ge1xuICAgICAgICBwcm9jZXNzSXNBbGl2ZSA9IGZhbHNlO1xuICAgICAgICBpZiAodGhpcy5zdGF0ZSAhPT0gQ2hyb21lZHJpdmVyLlNUQVRFX1NUT1BQRUQgJiZcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgIT09IENocm9tZWRyaXZlci5TVEFURV9TVE9QUElORyAmJlxuICAgICAgICAgICAgdGhpcy5zdGF0ZSAhPT0gQ2hyb21lZHJpdmVyLlNUQVRFX1JFU1RBUlRJTkcpIHtcbiAgICAgICAgICBsZXQgbXNnID0gYENocm9tZWRyaXZlciBleGl0ZWQgdW5leHBlY3RlZGx5IHdpdGggY29kZSAke2NvZGV9LCBgICtcbiAgICAgICAgICAgICAgICAgICAgYHNpZ25hbCAke3NpZ25hbH1gO1xuICAgICAgICAgIGxvZy5lcnJvcihtc2cpO1xuICAgICAgICAgIHRoaXMuY2hhbmdlU3RhdGUoQ2hyb21lZHJpdmVyLlNUQVRFX1NUT1BQRUQpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGxvZy5pbmZvKGBTcGF3bmluZyBjaHJvbWVkcml2ZXIgd2l0aDogJHt0aGlzLmNocm9tZWRyaXZlcn0gYCArXG4gICAgICAgICAgICAgICBgJHthcmdzLmpvaW4oJyAnKX1gKTtcbiAgICAgIC8vIHN0YXJ0IHN1YnByb2MgYW5kIHdhaXQgZm9yIHN0YXJ0RGV0ZWN0b3JcbiAgICAgIGF3YWl0IHRoaXMucHJvYy5zdGFydChzdGFydERldGVjdG9yKTtcbiAgICAgIGF3YWl0IHRoaXMud2FpdEZvck9ubGluZSgpO1xuICAgICAgYXdhaXQgdGhpcy5zdGFydFNlc3Npb24oKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICB0aGlzLmVtaXQoQ2hyb21lZHJpdmVyLkVWRU5UX0VSUk9SLCBlKTtcbiAgICAgIC8vIGp1c3QgYmVjYXVzZSB3ZSBoYWQgYW4gZXJyb3IgZG9lc24ndCBtZWFuIHRoZSBjaHJvbWVkcml2ZXIgcHJvY2Vzc1xuICAgICAgLy8gZmluaXNoZWQ7IHdlIHNob3VsZCBjbGVhbiB1cCBpZiBuZWNlc3NhcnlcbiAgICAgIGlmIChwcm9jZXNzSXNBbGl2ZSkge1xuICAgICAgICBhd2FpdCB0aGlzLnByb2Muc3RvcCgpO1xuICAgICAgfVxuICAgICAgbG9nLmVycm9yQW5kVGhyb3coZSk7XG4gICAgfVxuICB9XG5cbiAgc2Vzc2lvbklkICgpIHtcbiAgICBpZiAodGhpcy5zdGF0ZSAhPT0gQ2hyb21lZHJpdmVyLlNUQVRFX09OTElORSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuandwcm94eS5zZXNzaW9uSWQ7XG4gIH1cblxuICBhc3luYyByZXN0YXJ0ICgpIHtcbiAgICBsb2cuaW5mbyhcIlJlc3RhcnRpbmcgY2hyb21lZHJpdmVyXCIpO1xuICAgIGlmICh0aGlzLnN0YXRlICE9PSBDaHJvbWVkcml2ZXIuU1RBVEVfT05MSU5FKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW4ndCByZXN0YXJ0IHdoZW4gd2UncmUgbm90IG9ubGluZVwiKTtcbiAgICB9XG4gICAgdGhpcy5jaGFuZ2VTdGF0ZShDaHJvbWVkcml2ZXIuU1RBVEVfUkVTVEFSVElORyk7XG4gICAgYXdhaXQgdGhpcy5zdG9wKGZhbHNlKTtcbiAgICBhd2FpdCB0aGlzLnN0YXJ0KHRoaXMuY2FwYWJpbGl0aWVzLCBmYWxzZSk7XG4gIH1cblxuICBfc3RhdGVQcm9taXNlIChzdGF0ZSA9IG51bGwpIHtcbiAgICByZXR1cm4gbmV3IEIoKHJlc29sdmUpID0+IHtcbiAgICAgIGNvbnN0IGxpc3RlbmVyID0gKG1zZykgPT4ge1xuICAgICAgICBpZiAoc3RhdGUgPT09IG51bGwgfHwgbXNnLnN0YXRlID09PSBzdGF0ZSkge1xuICAgICAgICAgIHJlc29sdmUobXNnLnN0YXRlKTtcbiAgICAgICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKENocm9tZWRyaXZlci5FVkVOVF9DSEFOR0VELCBsaXN0ZW5lcik7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICB0aGlzLm9uKENocm9tZWRyaXZlci5FVkVOVF9DSEFOR0VELCBsaXN0ZW5lcik7XG4gICAgfSk7XG4gIH1cblxuICBhc3luYyB3YWl0Rm9yT25saW5lICgpIHtcbiAgICAvLyB3ZSBuZWVkIHRvIG1ha2Ugc3VyZSB0aGF0IENEIGhhc24ndCBjcmFzaGVkXG4gICAgbGV0IGNocm9tZWRyaXZlclN0b3BwZWQgPSBmYWxzZTtcbiAgICBhd2FpdCByZXRyeUludGVydmFsKDIwLCAyMDAsIGFzeW5jICgpID0+IHtcbiAgICAgIGlmICh0aGlzLnN0YXRlID09PSBDaHJvbWVkcml2ZXIuU1RBVEVfU1RPUFBFRCkge1xuICAgICAgICAvLyB3ZSBhcmUgZWl0aGVyIHN0b3BwZWQgb3Igc3RvcHBpbmcsIHNvIHNvbWV0aGluZyB3ZW50IHdyb25nXG4gICAgICAgIGNocm9tZWRyaXZlclN0b3BwZWQgPSB0cnVlO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBhd2FpdCB0aGlzLmdldFN0YXR1cygpO1xuICAgIH0pO1xuICAgIGlmIChjaHJvbWVkcml2ZXJTdG9wcGVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nocm9tZURyaXZlciBjcmFzaGVkIGR1cmluZyBzdGFydHVwLicpO1xuICAgIH1cbiAgfVxuXG4gIGFzeW5jIGdldFN0YXR1cyAoKSB7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuandwcm94eS5jb21tYW5kKCcvc3RhdHVzJywgJ0dFVCcpO1xuICB9XG5cbiAgYXN5bmMgc3RhcnRTZXNzaW9uICgpIHtcbiAgICAvLyByZXRyeSBzZXNzaW9uIHN0YXJ0IDQgdGltZXMsIHNvbWV0aW1lcyB0aGlzIGZhaWxzIGR1ZSB0byBhZGJcbiAgICBhd2FpdCByZXRyeUludGVydmFsKDQsIDIwMCwgdGhpcy5qd3Byb3h5LmNvbW1hbmQuYmluZCh0aGlzLmp3cHJveHkpLFxuICAgICAgICAnL3Nlc3Npb24nLCAnUE9TVCcsIHtkZXNpcmVkQ2FwYWJpbGl0aWVzOiB0aGlzLmNhcGFiaWxpdGllc30pO1xuICAgIHRoaXMuY2hhbmdlU3RhdGUoQ2hyb21lZHJpdmVyLlNUQVRFX09OTElORSk7XG4gIH1cblxuICBhc3luYyBzdG9wIChlbWl0U3RhdGVzID0gdHJ1ZSkge1xuICAgIGlmIChlbWl0U3RhdGVzKSB7XG4gICAgICB0aGlzLmNoYW5nZVN0YXRlKENocm9tZWRyaXZlci5TVEFURV9TVE9QUElORyk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICBhd2FpdCB0aGlzLmp3cHJveHkuY29tbWFuZCgnJywgJ0RFTEVURScpO1xuICAgICAgYXdhaXQgdGhpcy5wcm9jLnN0b3AoKTtcbiAgICAgIGlmIChlbWl0U3RhdGVzKSB7XG4gICAgICAgIHRoaXMuY2hhbmdlU3RhdGUoQ2hyb21lZHJpdmVyLlNUQVRFX1NUT1BQRUQpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGxvZy5lcnJvcihlKTtcbiAgICB9XG4gIH1cblxuICBjaGFuZ2VTdGF0ZSAoc3RhdGUpIHtcbiAgICB0aGlzLnN0YXRlID0gc3RhdGU7XG4gICAgbG9nLmRlYnVnKGBDaGFuZ2VkIHN0YXRlIHRvICcke3N0YXRlfSdgKTtcbiAgICB0aGlzLmVtaXQoQ2hyb21lZHJpdmVyLkVWRU5UX0NIQU5HRUQsIHtzdGF0ZX0pO1xuICB9XG5cbiAgYXN5bmMgc2VuZENvbW1hbmQgKHVybCwgbWV0aG9kLCBib2R5KSB7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuandwcm94eS5jb21tYW5kKHVybCwgbWV0aG9kLCBib2R5KTtcbiAgfVxuXG4gIGFzeW5jIHByb3h5UmVxIChyZXEsIHJlcykge1xuICAgIHJldHVybiBhd2FpdCB0aGlzLmp3cHJveHkucHJveHlSZXFSZXMocmVxLCByZXMpO1xuICB9XG5cbiAgYXN5bmMga2lsbEFsbCAoKSB7XG4gICAgbGV0IGNtZDtcbiAgICBpZiAoc3lzdGVtLmlzV2luZG93cygpKSB7XG4gICAgICAvLyBqcyBoaW50IGNhbm5vdCBoYW5kbGUgYmFja3RpY2tzLCBldmVuIGVzY2FwZWQsIHdpdGhpbiB0ZW1wbGF0ZSBsaXRlcmFsc1xuICAgICAgY21kID0gXCJGT1IgL0YgXFxcInVzZWJhY2txIHRva2Vucz01XFxcIiAlYSBpbiAoYG5ldHN0YXQgLW5hbyBefCBcIiArXG4gICAgICAgICAgICBcImZpbmRzdHIgL1IgL0M6XFxcIlwiICsgdGhpcy5wcm94eVBvcnQgKyBcIiBcXFwiYCkgZG8gKFwiICtcbiAgICAgICAgICAgIFwiRk9SIC9GIFxcXCJ1c2ViYWNrcVxcXCIgJWIgaW4gKGBUQVNLTElTVCAvRkkgXFxcIlBJRCBlcSAlYVxcXCIgXnwgXCIgK1xuICAgICAgICAgICAgXCJmaW5kc3RyIC9JIGNocm9tZWRyaXZlci5leGVgKSBkbyAoSUYgTk9UICViPT1cXFwiXFxcIiBUQVNLS0lMTCBcIiArXG4gICAgICAgICAgICBcIi9GIC9QSUQgJWEpKVwiO1xuICAgIH0gZWxzZSB7XG4gICAgICBjbWQgPSBgcHMgLWVmIHwgZ3JlcCAke3RoaXMuY2hyb21lZHJpdmVyfSB8IGdyZXAgLXYgZ3JlcCB8YCArXG4gICAgICAgICAgICBgZ3JlcCAtZSAnLS1wb3J0PSR7dGhpcy5wcm94eVBvcnR9XFxcXChcXFxccy4qXFxcXClcXFxcPyQnIHwgYXdrIGAgK1xuICAgICAgICAgICAgYCd7IHByaW50ICQyIH0nIHwgeGFyZ3Mga2lsbCAtMTVgO1xuICAgIH1cbiAgICBsb2cuaW5mbyhgS2lsbGluZyBhbnkgb2xkIGNocm9tZWRyaXZlcnMsIHJ1bm5pbmc6ICR7Y21kfWApO1xuICAgIHRyeSB7XG4gICAgICBhd2FpdCAoQi5wcm9taXNpZnkoY3AuZXhlYykpKGNtZCk7XG4gICAgICBsb2cuaW5mbyhcIlN1Y2Nlc3NmdWxseSBjbGVhbmVkIHVwIG9sZCBjaHJvbWVkcml2ZXJzXCIpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgbG9nLmluZm8oXCJObyBvbGQgY2hyb21lZHJpdmVycyBzZWVtZWQgdG8gZXhpc3RcIik7XG4gICAgfVxuICB9XG5cbiAgYXN5bmMgaGFzV29ya2luZ1dlYnZpZXcgKCkge1xuICAgIC8vIHNvbWV0aW1lcyBjaHJvbWVkcml2ZXIgc3RvcHMgYXV0b21hdGluZyB3ZWJ2aWV3cy4gdGhpcyBtZXRob2QgcnVucyBhXG4gICAgLy8gc2ltcGxlIGNvbW1hbmQgdG8gZGV0ZXJtaW5lIG91ciBzdGF0ZSwgYW5kIHJlc3BvbmRzIGFjY29yZGluZ2x5XG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IHRoaXMuandwcm94eS5jb21tYW5kKCcvdXJsJywgJ0dFVCcpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxufVxuXG5DaHJvbWVkcml2ZXIuRVZFTlRfRVJST1IgPSAnY2hyb21lZHJpdmVyX2Vycm9yJztcbkNocm9tZWRyaXZlci5FVkVOVF9DSEFOR0VEID0gJ3N0YXRlQ2hhbmdlZCc7XG5DaHJvbWVkcml2ZXIuU1RBVEVfU1RPUFBFRCA9ICdzdG9wcGVkJztcbkNocm9tZWRyaXZlci5TVEFURV9TVEFSVElORyA9ICdzdGFydGluZyc7XG5DaHJvbWVkcml2ZXIuU1RBVEVfT05MSU5FID0gJ29ubGluZSc7XG5DaHJvbWVkcml2ZXIuU1RBVEVfU1RPUFBJTkcgPSAnc3RvcHBpbmcnO1xuQ2hyb21lZHJpdmVyLlNUQVRFX1JFU1RBUlRJTkcgPSAncmVzdGFydGluZyc7XG5cbmV4cG9ydCBkZWZhdWx0IENocm9tZWRyaXZlcjtcbiJdfQ==