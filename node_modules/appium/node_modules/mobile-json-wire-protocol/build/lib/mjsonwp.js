'use strict';

var _classCallCheck = require('babel-runtime/helpers/class-call-check')['default'];

var _toConsumableArray = require('babel-runtime/helpers/to-consumable-array')['default'];

var _slicedToArray = require('babel-runtime/helpers/sliced-to-array')['default'];

var _getIterator = require('babel-runtime/core-js/get-iterator')['default'];

var _regeneratorRuntime = require('babel-runtime/regenerator')['default'];

var _interopRequireDefault = require('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _lodash = require('lodash');

var _lodash2 = _interopRequireDefault(_lodash);

var _appiumLogger = require('appium-logger');

var _validators = require('./validators');

var _errors = require('./errors');

var _routes = require('./routes');

var _bluebird = require('bluebird');

var _bluebird2 = _interopRequireDefault(_bluebird);

var log = (0, _appiumLogger.getLogger)('MJSONWP');
var JSONWP_SUCCESS_STATUS_CODE = 0;
var LOG_OBJ_LENGTH = 150;

var MJSONWP = function MJSONWP() {
  _classCallCheck(this, MJSONWP);
};

function isSessionCommand(command) {
  return !_lodash2['default'].contains(_routes.NO_SESSION_ID_COMMANDS, command);
}

function wrapParams(paramSets, jsonObj) {
  /* There are commands like performTouch which take a single parameter (primitive type or array).
   * Some drivers choose to pass this parameter as a value (eg. [action1, action2...]) while others to
   * wrap it within an object(eg' {gesture:  [action1, action2...]}), which makes it hard to validate.
   * The wrap option in the spec enforce wrapping before validation, so that all params are wrapped at
   * the time they are validated and later passed to the commands.
   */
  var res = jsonObj;
  if (_lodash2['default'].isArray(jsonObj) || !_lodash2['default'].isObject(jsonObj)) {
    res = {};
    res[paramSets.wrap] = jsonObj;
  }
  return res;
}

function unwrapParams(paramSets, jsonObj) {
  /* There are commands like setNetworkConnection which send parameters wrapped inside a key such as
   * "parameters". This function unwraps them (eg. {"parameters": {"type": 1}} becomes {"type": 1}).
   */
  var res = jsonObj;
  if (_lodash2['default'].isObject(jsonObj)) {
    // some clients, like ruby, don't wrap
    if (jsonObj[paramSets.unwrap]) {
      res = jsonObj[paramSets.unwrap];
    }
  }
  return res;
}

function checkParams(paramSets, jsonObj) {
  var requiredParams = [];
  var optionalParams = [];
  var receivedParams = _lodash2['default'].keys(jsonObj);

  if (paramSets) {
    if (paramSets.required) {
      // we might have an array of parameters,
      // or an array of arrays of parameters, so standardize
      if (!_lodash2['default'].isArray(_lodash2['default'].first(paramSets.required))) {
        requiredParams = [paramSets.required];
      } else {
        requiredParams = paramSets.required;
      }
    }
    // optional parameters are just an array
    if (paramSets.optional) {
      optionalParams = paramSets.optional;
    }
  }

  // if we have no required parameters, all is well
  if (requiredParams.length === 0) {
    return;
  }

  // some clients pass in the session id in the params
  optionalParams.push('sessionId');

  // some clients pass in an element id in the params
  optionalParams.push('id');

  // go through the required parameters and check against our arguments
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = _getIterator(requiredParams), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var params = _step.value;

      if (_lodash2['default'].difference(receivedParams, params, optionalParams).length === 0 && _lodash2['default'].difference(params, receivedParams).length === 0) {
        // we have a set of parameters that is correct
        // so short-circuit
        return;
      }
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator['return']) {
        _iterator['return']();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  throw new _errors.errors.BadParametersError(paramSets, receivedParams);
}

function makeArgs(reqParams, jsonObj, payloadParams) {
  // we want to pass the url parameters to the commands in reverse order
  // since the command will sometimes want to ignore, say, the sessionId
  var urlParams = _lodash2['default'].keys(reqParams).reverse();

  // there can be multiple sets of required params, so find the correct one
  var realRequiredParams = payloadParams.required;
  if (_lodash2['default'].isArray(_lodash2['default'].first(payloadParams.required))) {
    var keys = _lodash2['default'].keys(jsonObj);
    var _iteratorNormalCompletion2 = true;
    var _didIteratorError2 = false;
    var _iteratorError2 = undefined;

    try {
      for (var _iterator2 = _getIterator(payloadParams.required), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
        var params = _step2.value;

        // check if all the required parameters are in the json object
        if (_lodash2['default'].without.apply(_lodash2['default'], [params].concat(_toConsumableArray(keys))).length === 0) {
          // we have all the parameters for this set
          realRequiredParams = params;
          break;
        }
      }
    } catch (err) {
      _didIteratorError2 = true;
      _iteratorError2 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion2 && _iterator2['return']) {
          _iterator2['return']();
        }
      } finally {
        if (_didIteratorError2) {
          throw _iteratorError2;
        }
      }
    }
  }
  var args = _lodash2['default'].flatten(realRequiredParams).map(function (p) {
    return jsonObj[p];
  });

  if (payloadParams.optional) {
    args = args.concat(_lodash2['default'].flatten(payloadParams.optional).map(function (p) {
      return jsonObj[p];
    }));
  }
  args = args.concat(urlParams.map(function (u) {
    return reqParams[u];
  }));
  return args;
}

function getResponseForJsonwpError(err) {
  var httpStatus = 500;
  var httpResBody = {
    status: err.jsonwpCode,
    value: {
      message: err.message
    }
  };

  if ((0, _errors.isErrorType)(err, _errors.errors.BadParametersError)) {
    // respond with a 400 if we have bad parameters
    log.debug('Bad parameters: ' + err);
    httpStatus = 400;
    httpResBody = err.message;
  } else if ((0, _errors.isErrorType)(err, _errors.errors.NotYetImplementedError) || (0, _errors.isErrorType)(err, _errors.errors.NotImplementedError)) {
    // respond with a 501 if the method is not implemented
    httpStatus = 501;
  } else if ((0, _errors.isErrorType)(err, _errors.errors.NoSuchDriverError)) {
    // respond with a 404 if there is no driver for the session
    httpStatus = 404;
  }

  return [httpStatus, httpResBody];
}

function routeConfiguringFunction(driver) {
  if (!driver.sessionExists) {
    throw new Error('Drivers used with MJSONWP must implement `sessionExists`');
  }

  if (!(driver.executeCommand || driver.execute)) {
    throw new Error('Drivers used with MJSONWP must implement `executeCommand` or `execute`');
  }

  // return a function which will add all the routes to the driver
  return function (app) {
    var _iteratorNormalCompletion3 = true;
    var _didIteratorError3 = false;
    var _iteratorError3 = undefined;

    try {
      for (var _iterator3 = _getIterator(_lodash2['default'].pairs(_routes.METHOD_MAP)), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
        var _step3$value = _slicedToArray(_step3.value, 2);

        var path = _step3$value[0];
        var methods = _step3$value[1];
        var _iteratorNormalCompletion4 = true;
        var _didIteratorError4 = false;
        var _iteratorError4 = undefined;

        try {
          for (var _iterator4 = _getIterator(_lodash2['default'].pairs(methods)), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
            var _step4$value = _slicedToArray(_step4.value, 2);

            var method = _step4$value[0];
            var spec = _step4$value[1];

            var isSessCmd = isSessionCommand(spec.command);

            // set up the express route handler
            buildHandler(app, method, path, spec, driver, isSessCmd);
          }
        } catch (err) {
          _didIteratorError4 = true;
          _iteratorError4 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion4 && _iterator4['return']) {
              _iterator4['return']();
            }
          } finally {
            if (_didIteratorError4) {
              throw _iteratorError4;
            }
          }
        }
      }
    } catch (err) {
      _didIteratorError3 = true;
      _iteratorError3 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion3 && _iterator3['return']) {
          _iterator3['return']();
        }
      } finally {
        if (_didIteratorError3) {
          throw _iteratorError3;
        }
      }
    }
  };
}

function buildHandler(app, method, path, spec, driver, isSessCmd) {
  var _this = this;

  var asyncHandler = function asyncHandler(req, res) {
    var jsonObj, httpResBody, httpStatus, newSessionId, args, driverRes, actualErr, _getResponseForJsonwpError, _getResponseForJsonwpError2;

    return _regeneratorRuntime.async(function asyncHandler$(context$2$0) {
      while (1) switch (context$2$0.prev = context$2$0.next) {
        case 0:
          jsonObj = req.body;
          httpResBody = {};
          httpStatus = 200;
          newSessionId = undefined;
          context$2$0.prev = 4;

          if (!(isSessCmd && !driver.sessionExists(req.params.sessionId))) {
            context$2$0.next = 7;
            break;
          }

          throw new _errors.errors.NoSuchDriverError();

        case 7:
          if (!(isSessCmd && driverShouldDoJwpProxy(driver, req, spec.command))) {
            context$2$0.next = 11;
            break;
          }

          context$2$0.next = 10;
          return _regeneratorRuntime.awrap(doJwpProxy(driver, req, res));

        case 10:
          return context$2$0.abrupt('return');

        case 11:
          if (spec.command) {
            context$2$0.next = 13;
            break;
          }

          throw new _errors.errors.NotImplementedError();

        case 13:

          // wrap params if necessary
          if (spec.payloadParams && spec.payloadParams.wrap) {
            jsonObj = wrapParams(spec.payloadParams, jsonObj);
          }

          // unwrap params if necessary
          if (spec.payloadParams && spec.payloadParams.unwrap) {
            jsonObj = unwrapParams(spec.payloadParams, jsonObj);
          }

          // ensure that the json payload conforms to the spec
          checkParams(spec.payloadParams, jsonObj);
          // ensure the session the user is trying to use is valid

          // turn the command and json payload into an argument list for
          // the driver methods
          args = makeArgs(req.params, jsonObj, spec.payloadParams || []);
          driverRes = undefined;

          // validate command args according to MJSONWP
          if (_validators.validators[spec.command]) {
            _validators.validators[spec.command].apply(_validators.validators, _toConsumableArray(args));
          }
          // run the driver command wrapped inside the argument validators
          log.info('Calling ' + driver.constructor.name + '.' + spec.command + '() with args: ' + _lodash2['default'].trunc(JSON.stringify(args), LOG_OBJ_LENGTH));

          if (!driver.executeCommand) {
            context$2$0.next = 26;
            break;
          }

          context$2$0.next = 23;
          return _regeneratorRuntime.awrap(driver.executeCommand.apply(driver, [spec.command].concat(_toConsumableArray(args))));

        case 23:
          driverRes = context$2$0.sent;
          context$2$0.next = 29;
          break;

        case 26:
          context$2$0.next = 28;
          return _regeneratorRuntime.awrap(driver.execute.apply(driver, [spec.command].concat(_toConsumableArray(args))));

        case 28:
          driverRes = context$2$0.sent;

        case 29:

          // unpack createSession response
          if (spec.command === 'createSession') {
            newSessionId = driverRes[0];
            driverRes = driverRes[1];
          }

          // convert undefined to null, but leave all other values the same
          if (_lodash2['default'].isUndefined(driverRes)) {
            driverRes = null;
          }

          // delete should not return anything even if successful
          if (spec.command === 'deleteSession') {
            log.debug('Received response: ' + _lodash2['default'].trunc(JSON.stringify(driverRes), LOG_OBJ_LENGTH));
            log.debug('But deleting session, so not returning');
            driverRes = null;
          }

          // assuming everything worked, set up the json response object
          httpResBody.status = JSONWP_SUCCESS_STATUS_CODE;
          httpResBody.value = driverRes;
          log.info('Responding to client with driver.' + spec.command + '() ' + ('result: ' + _lodash2['default'].trunc(JSON.stringify(driverRes), LOG_OBJ_LENGTH)));
          context$2$0.next = 45;
          break;

        case 37:
          context$2$0.prev = 37;
          context$2$0.t0 = context$2$0['catch'](4);
          actualErr = context$2$0.t0;

          if (!((0, _errors.isErrorType)(context$2$0.t0, _errors.MJSONWPError) || (0, _errors.isErrorType)(context$2$0.t0, _errors.errors.BadParametersError))) {
            log.error('Encountered internal error running command: ' + context$2$0.t0.stack);
            actualErr = new _errors.errors.UnknownError(context$2$0.t0);
          }
          // if anything goes wrong, figure out what our response should be
          // based on the type of error that we encountered
          _getResponseForJsonwpError = getResponseForJsonwpError(actualErr);
          _getResponseForJsonwpError2 = _slicedToArray(_getResponseForJsonwpError, 2);
          httpStatus = _getResponseForJsonwpError2[0];
          httpResBody = _getResponseForJsonwpError2[1];

        case 45:

          // decode the response, which is either a string or json
          if (_lodash2['default'].isString(httpResBody)) {
            res.status(httpStatus).send(httpResBody);
          } else {
            if (newSessionId) {
              httpResBody.sessionId = newSessionId;
            } else {
              httpResBody.sessionId = req.params.sessionId || null;
            }

            res.status(httpStatus).json(httpResBody);
          }

        case 46:
        case 'end':
          return context$2$0.stop();
      }
    }, null, _this, [[4, 37]]);
  };
  // add the method to the app
  app[method.toLowerCase()](path, function (req, res) {
    _bluebird2['default'].resolve(asyncHandler(req, res)).done();
  });
}

function driverShouldDoJwpProxy(driver, req, command) {
  // drivers need to explicitly say when the proxy is active
  if (!driver.proxyActive(req.params.sessionId)) {
    return false;
  }

  // we should never proxy deleteSession because we need to give the containing
  // driver an opportunity to clean itself up
  if (command === 'deleteSession') {
    return false;
  }

  // validate avoidance schema, and say we shouldn't proxy if anything in the
  // avoid list matches our req
  var proxyAvoidList = driver.getProxyAvoidList(req.params.sessionId);
  var _iteratorNormalCompletion5 = true;
  var _didIteratorError5 = false;
  var _iteratorError5 = undefined;

  try {
    for (var _iterator5 = _getIterator(proxyAvoidList), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
      var avoidSchema = _step5.value;

      if (!_lodash2['default'].isArray(avoidSchema) || avoidSchema.length !== 2) {
        throw new Error('Proxy avoidance must be a list of pairs');
      }

      var _avoidSchema = _slicedToArray(avoidSchema, 2);

      var avoidMethod = _avoidSchema[0];
      var avoidPathRegex = _avoidSchema[1];

      if (!_lodash2['default'].contains(['GET', 'POST', 'DELETE'], avoidMethod)) {
        throw new Error('Unrecognized proxy avoidance method \'' + avoidMethod + '\'');
      }
      if (!(avoidPathRegex instanceof RegExp)) {
        throw new Error('Proxy avoidance path must be a regular expression');
      }
      var normalizedUrl = req.originalUrl.replace(/^\/wd\/hub/, '');
      if (avoidMethod === req.method && avoidPathRegex.test(normalizedUrl)) {
        return false;
      }
    }
  } catch (err) {
    _didIteratorError5 = true;
    _iteratorError5 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion5 && _iterator5['return']) {
        _iterator5['return']();
      }
    } finally {
      if (_didIteratorError5) {
        throw _iteratorError5;
      }
    }
  }

  return true;
}

function doJwpProxy(driver, req, res) {
  return _regeneratorRuntime.async(function doJwpProxy$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        log.info('Driver proxy active, passing request on via HTTP proxy');

        // check that the inner driver has a proxy function

        if (driver.canProxy(req.params.sessionId)) {
          context$1$0.next = 3;
          break;
        }

        throw new Error('Trying to proxy to a JSONWP server but driver is unable to proxy');

      case 3:
        context$1$0.prev = 3;
        context$1$0.next = 6;
        return _regeneratorRuntime.awrap(driver.executeCommand('proxyReqRes', req, res, req.params.sessionId));

      case 6:
        context$1$0.next = 11;
        break;

      case 8:
        context$1$0.prev = 8;
        context$1$0.t0 = context$1$0['catch'](3);
        throw new Error('Could not proxy. Proxy error: ' + context$1$0.t0.message);

      case 11:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this, [[3, 8]]);
}

exports.MJSONWP = MJSONWP;
exports.routeConfiguringFunction = routeConfiguringFunction;
exports.isSessionCommand = isSessionCommand;

// if this is a session command but we don't have a session,
// error out early (especially before proxying)

// if the driver is currently proxying commands to another JSONWP
// server, bypass all our checks and assume the upstream server knows
// what it's doing. But keep this in the try/catch block so if proxying
// itself fails, we give a message to the client. Of course we only
// want to do these when we have a session command; the Appium driver
// must be responsible for start/stop session, etc...

// if a command is not in our method map, it's because we
// have no plans to ever implement it
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImxpYi9tanNvbndwLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7OztzQkFBYyxRQUFROzs7OzRCQUNJLGVBQWU7OzBCQUNkLGNBQWM7O3NCQUNTLFVBQVU7O3NCQUNULFVBQVU7O3dCQUMvQyxVQUFVOzs7O0FBR3hCLElBQU0sR0FBRyxHQUFHLDZCQUFVLFNBQVMsQ0FBQyxDQUFDO0FBQ2pDLElBQU0sMEJBQTBCLEdBQUcsQ0FBQyxDQUFDO0FBQ3JDLElBQU0sY0FBYyxHQUFHLEdBQUcsQ0FBQzs7SUFFckIsT0FBTyxZQUFQLE9BQU87d0JBQVAsT0FBTzs7O0FBRWIsU0FBUyxnQkFBZ0IsQ0FBRSxPQUFPLEVBQUU7QUFDbEMsU0FBTyxDQUFDLG9CQUFFLFFBQVEsaUNBQXlCLE9BQU8sQ0FBQyxDQUFDO0NBQ3JEOztBQUVELFNBQVMsVUFBVSxDQUFFLFNBQVMsRUFBRSxPQUFPLEVBQUU7Ozs7Ozs7QUFPdkMsTUFBSSxHQUFHLEdBQUcsT0FBTyxDQUFDO0FBQ2xCLE1BQUksb0JBQUUsT0FBTyxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsb0JBQUUsUUFBUSxDQUFDLE9BQU8sQ0FBQyxFQUFFO0FBQzlDLE9BQUcsR0FBRyxFQUFFLENBQUM7QUFDVCxPQUFHLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxHQUFHLE9BQU8sQ0FBQztHQUMvQjtBQUNELFNBQU8sR0FBRyxDQUFDO0NBQ1o7O0FBRUQsU0FBUyxZQUFZLENBQUUsU0FBUyxFQUFFLE9BQU8sRUFBRTs7OztBQUl6QyxNQUFJLEdBQUcsR0FBRyxPQUFPLENBQUM7QUFDbEIsTUFBSSxvQkFBRSxRQUFRLENBQUMsT0FBTyxDQUFDLEVBQUU7O0FBRXZCLFFBQUksT0FBTyxDQUFDLFNBQVMsQ0FBQyxNQUFNLENBQUMsRUFBRTtBQUM3QixTQUFHLEdBQUcsT0FBTyxDQUFDLFNBQVMsQ0FBQyxNQUFNLENBQUMsQ0FBQztLQUNqQztHQUNGO0FBQ0QsU0FBTyxHQUFHLENBQUM7Q0FDWjs7QUFFRCxTQUFTLFdBQVcsQ0FBRSxTQUFTLEVBQUUsT0FBTyxFQUFFO0FBQ3hDLE1BQUksY0FBYyxHQUFHLEVBQUUsQ0FBQztBQUN4QixNQUFJLGNBQWMsR0FBRyxFQUFFLENBQUM7QUFDeEIsTUFBSSxjQUFjLEdBQUcsb0JBQUUsSUFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDOztBQUVyQyxNQUFJLFNBQVMsRUFBRTtBQUNiLFFBQUksU0FBUyxDQUFDLFFBQVEsRUFBRTs7O0FBR3RCLFVBQUksQ0FBQyxvQkFBRSxPQUFPLENBQUMsb0JBQUUsS0FBSyxDQUFDLFNBQVMsQ0FBQyxRQUFRLENBQUMsQ0FBQyxFQUFFO0FBQzNDLHNCQUFjLEdBQUcsQ0FBQyxTQUFTLENBQUMsUUFBUSxDQUFDLENBQUM7T0FDdkMsTUFBTTtBQUNMLHNCQUFjLEdBQUcsU0FBUyxDQUFDLFFBQVEsQ0FBQztPQUNyQztLQUNGOztBQUVELFFBQUksU0FBUyxDQUFDLFFBQVEsRUFBRTtBQUN0QixvQkFBYyxHQUFHLFNBQVMsQ0FBQyxRQUFRLENBQUM7S0FDckM7R0FDRjs7O0FBR0QsTUFBSSxjQUFjLENBQUMsTUFBTSxLQUFLLENBQUMsRUFBRTtBQUMvQixXQUFPO0dBQ1I7OztBQUdELGdCQUFjLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxDQUFDOzs7QUFHakMsZ0JBQWMsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7Ozs7Ozs7O0FBRzFCLHNDQUFtQixjQUFjLDRHQUFFO1VBQTFCLE1BQU07O0FBQ2IsVUFBSSxvQkFBRSxVQUFVLENBQUMsY0FBYyxFQUFFLE1BQU0sRUFBRSxjQUFjLENBQUMsQ0FBQyxNQUFNLEtBQUssQ0FBQyxJQUNqRSxvQkFBRSxVQUFVLENBQUMsTUFBTSxFQUFFLGNBQWMsQ0FBQyxDQUFDLE1BQU0sS0FBSyxDQUFDLEVBQUU7OztBQUdyRCxlQUFPO09BQ1I7S0FDRjs7Ozs7Ozs7Ozs7Ozs7OztBQUNELFFBQU0sSUFBSSxlQUFPLGtCQUFrQixDQUFDLFNBQVMsRUFBRSxjQUFjLENBQUMsQ0FBQztDQUNoRTs7QUFFRCxTQUFTLFFBQVEsQ0FBRSxTQUFTLEVBQUUsT0FBTyxFQUFFLGFBQWEsRUFBRTs7O0FBR3BELE1BQUksU0FBUyxHQUFHLG9CQUFFLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQyxPQUFPLEVBQUUsQ0FBQzs7O0FBRzVDLE1BQUksa0JBQWtCLEdBQUcsYUFBYSxDQUFDLFFBQVEsQ0FBQztBQUNoRCxNQUFJLG9CQUFFLE9BQU8sQ0FBQyxvQkFBRSxLQUFLLENBQUMsYUFBYSxDQUFDLFFBQVEsQ0FBQyxDQUFDLEVBQUU7QUFDOUMsUUFBSSxJQUFJLEdBQUcsb0JBQUUsSUFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDOzs7Ozs7QUFDM0IseUNBQW1CLGFBQWEsQ0FBQyxRQUFRLGlIQUFFO1lBQWxDLE1BQU07OztBQUViLFlBQUksb0JBQUUsT0FBTyxNQUFBLHVCQUFDLE1BQU0sNEJBQUssSUFBSSxHQUFDLENBQUMsTUFBTSxLQUFLLENBQUMsRUFBRTs7QUFFM0MsNEJBQWtCLEdBQUcsTUFBTSxDQUFDO0FBQzVCLGdCQUFNO1NBQ1A7T0FDRjs7Ozs7Ozs7Ozs7Ozs7O0dBQ0Y7QUFDRCxNQUFJLElBQUksR0FBRyxvQkFBRSxPQUFPLENBQUMsa0JBQWtCLENBQUMsQ0FBQyxHQUFHLENBQUMsVUFBQSxDQUFDO1dBQUksT0FBTyxDQUFDLENBQUMsQ0FBQztHQUFBLENBQUMsQ0FBQzs7QUFFOUQsTUFBSSxhQUFhLENBQUMsUUFBUSxFQUFFO0FBQzFCLFFBQUksR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDLG9CQUFFLE9BQU8sQ0FBQyxhQUFhLENBQUMsUUFBUSxDQUFDLENBQUMsR0FBRyxDQUFDLFVBQUEsQ0FBQzthQUFJLE9BQU8sQ0FBQyxDQUFDLENBQUM7S0FBQSxDQUFDLENBQUMsQ0FBQztHQUM1RTtBQUNELE1BQUksR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDLFNBQVMsQ0FBQyxHQUFHLENBQUMsVUFBQSxDQUFDO1dBQUksU0FBUyxDQUFDLENBQUMsQ0FBQztHQUFBLENBQUMsQ0FBQyxDQUFDO0FBQ3JELFNBQU8sSUFBSSxDQUFDO0NBQ2I7O0FBRUQsU0FBUyx5QkFBeUIsQ0FBRSxHQUFHLEVBQUU7QUFDdkMsTUFBSSxVQUFVLEdBQUcsR0FBRyxDQUFDO0FBQ3JCLE1BQUksV0FBVyxHQUFHO0FBQ2hCLFVBQU0sRUFBRSxHQUFHLENBQUMsVUFBVTtBQUN0QixTQUFLLEVBQUU7QUFDTCxhQUFPLEVBQUUsR0FBRyxDQUFDLE9BQU87S0FDckI7R0FDRixDQUFDOztBQUVGLE1BQUkseUJBQVksR0FBRyxFQUFFLGVBQU8sa0JBQWtCLENBQUMsRUFBRTs7QUFFL0MsT0FBRyxDQUFDLEtBQUssc0JBQW9CLEdBQUcsQ0FBRyxDQUFDO0FBQ3BDLGNBQVUsR0FBRyxHQUFHLENBQUM7QUFDakIsZUFBVyxHQUFHLEdBQUcsQ0FBQyxPQUFPLENBQUM7R0FDM0IsTUFBTSxJQUFJLHlCQUFZLEdBQUcsRUFBRSxlQUFPLHNCQUFzQixDQUFDLElBQy9DLHlCQUFZLEdBQUcsRUFBRSxlQUFPLG1CQUFtQixDQUFDLEVBQUU7O0FBRXZELGNBQVUsR0FBRyxHQUFHLENBQUM7R0FDbEIsTUFBTSxJQUFJLHlCQUFZLEdBQUcsRUFBRSxlQUFPLGlCQUFpQixDQUFDLEVBQUU7O0FBRXJELGNBQVUsR0FBRyxHQUFHLENBQUM7R0FDbEI7O0FBR0QsU0FBTyxDQUFDLFVBQVUsRUFBRSxXQUFXLENBQUMsQ0FBQztDQUNsQzs7QUFFRCxTQUFTLHdCQUF3QixDQUFFLE1BQU0sRUFBRTtBQUN6QyxNQUFJLENBQUMsTUFBTSxDQUFDLGFBQWEsRUFBRTtBQUN6QixVQUFNLElBQUksS0FBSyxDQUFDLDBEQUEwRCxDQUFDLENBQUM7R0FDN0U7O0FBRUQsTUFBSSxFQUFFLE1BQU0sQ0FBQyxjQUFjLElBQUksTUFBTSxDQUFDLE9BQU8sQ0FBQSxBQUFDLEVBQUU7QUFDOUMsVUFBTSxJQUFJLEtBQUssQ0FBQyx3RUFBd0UsQ0FBQyxDQUFDO0dBQzNGOzs7QUFHRCxTQUFPLFVBQVUsR0FBRyxFQUFFOzs7Ozs7QUFDcEIseUNBQTRCLG9CQUFFLEtBQUssb0JBQVksaUhBQUU7OztZQUF2QyxJQUFJO1lBQUUsT0FBTzs7Ozs7O0FBQ3JCLDZDQUEyQixvQkFBRSxLQUFLLENBQUMsT0FBTyxDQUFDLGlIQUFFOzs7Z0JBQW5DLE1BQU07Z0JBQUUsSUFBSTs7QUFDcEIsZ0JBQUksU0FBUyxHQUFHLGdCQUFnQixDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQzs7O0FBRy9DLHdCQUFZLENBQUMsR0FBRyxFQUFFLE1BQU0sRUFBRSxJQUFJLEVBQUUsSUFBSSxFQUFFLE1BQU0sRUFBRSxTQUFTLENBQUMsQ0FBQztXQUMxRDs7Ozs7Ozs7Ozs7Ozs7O09BQ0Y7Ozs7Ozs7Ozs7Ozs7OztHQUNGLENBQUM7Q0FDSDs7QUFFRCxTQUFTLFlBQVksQ0FBRSxHQUFHLEVBQUUsTUFBTSxFQUFFLElBQUksRUFBRSxJQUFJLEVBQUUsTUFBTSxFQUFFLFNBQVMsRUFBRTs7O0FBQ2pFLE1BQUksWUFBWSxHQUFHLFNBQWYsWUFBWSxDQUFVLEdBQUcsRUFBRSxHQUFHO1FBQzVCLE9BQU8sRUFDUCxXQUFXLEVBQ1gsVUFBVSxFQUNWLFlBQVksRUF5Q1YsSUFBSSxFQUNKLFNBQVMsRUF1Q1QsU0FBUzs7Ozs7QUFwRlgsaUJBQU8sR0FBRyxHQUFHLENBQUMsSUFBSTtBQUNsQixxQkFBVyxHQUFHLEVBQUU7QUFDaEIsb0JBQVUsR0FBRyxHQUFHO0FBQ2hCLHNCQUFZOzs7Z0JBSVYsU0FBUyxJQUFJLENBQUMsTUFBTSxDQUFDLGFBQWEsQ0FBQyxHQUFHLENBQUMsTUFBTSxDQUFDLFNBQVMsQ0FBQyxDQUFBOzs7OztnQkFDcEQsSUFBSSxlQUFPLGlCQUFpQixFQUFFOzs7Z0JBU2xDLFNBQVMsSUFBSSxzQkFBc0IsQ0FBQyxNQUFNLEVBQUUsR0FBRyxFQUFFLElBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQTs7Ozs7OzJDQUMxRCxVQUFVLENBQUMsTUFBTSxFQUFFLEdBQUcsRUFBRSxHQUFHLENBQUM7Ozs7OztjQU0vQixJQUFJLENBQUMsT0FBTzs7Ozs7Z0JBQ1QsSUFBSSxlQUFPLG1CQUFtQixFQUFFOzs7OztBQUl4QyxjQUFJLElBQUksQ0FBQyxhQUFhLElBQUksSUFBSSxDQUFDLGFBQWEsQ0FBQyxJQUFJLEVBQUU7QUFDakQsbUJBQU8sR0FBRyxVQUFVLENBQUMsSUFBSSxDQUFDLGFBQWEsRUFBRSxPQUFPLENBQUMsQ0FBQztXQUNuRDs7O0FBR0QsY0FBSSxJQUFJLENBQUMsYUFBYSxJQUFJLElBQUksQ0FBQyxhQUFhLENBQUMsTUFBTSxFQUFFO0FBQ25ELG1CQUFPLEdBQUcsWUFBWSxDQUFDLElBQUksQ0FBQyxhQUFhLEVBQUUsT0FBTyxDQUFDLENBQUM7V0FDckQ7OztBQUdELHFCQUFXLENBQUMsSUFBSSxDQUFDLGFBQWEsRUFBRSxPQUFPLENBQUMsQ0FBQzs7Ozs7QUFLckMsY0FBSSxHQUFHLFFBQVEsQ0FBQyxHQUFHLENBQUMsTUFBTSxFQUFFLE9BQU8sRUFBRSxJQUFJLENBQUMsYUFBYSxJQUFJLEVBQUUsQ0FBQztBQUM5RCxtQkFBUzs7O0FBRWIsY0FBSSx1QkFBVyxJQUFJLENBQUMsT0FBTyxDQUFDLEVBQUU7QUFDNUIsbUNBQVcsSUFBSSxDQUFDLE9BQU8sT0FBQyw0Q0FBSSxJQUFJLEVBQUMsQ0FBQztXQUNuQzs7QUFFRCxhQUFHLENBQUMsSUFBSSxDQUFDLGFBQVcsTUFBTSxDQUFDLFdBQVcsQ0FBQyxJQUFJLFNBQUksSUFBSSxDQUFDLE9BQU8sc0JBQ2pELG9CQUFFLEtBQUssQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxFQUFFLGNBQWMsQ0FBQyxDQUFDLENBQUM7O2VBRXJELE1BQU0sQ0FBQyxjQUFjOzs7Ozs7MkNBQ0wsTUFBTSxDQUFDLGNBQWMsTUFBQSxDQUFyQixNQUFNLEdBQWdCLElBQUksQ0FBQyxPQUFPLDRCQUFLLElBQUksR0FBQzs7O0FBQTlELG1CQUFTOzs7Ozs7MkNBRVMsTUFBTSxDQUFDLE9BQU8sTUFBQSxDQUFkLE1BQU0sR0FBUyxJQUFJLENBQUMsT0FBTyw0QkFBSyxJQUFJLEdBQUM7OztBQUF2RCxtQkFBUzs7Ozs7QUFJWCxjQUFJLElBQUksQ0FBQyxPQUFPLEtBQUssZUFBZSxFQUFFO0FBQ3BDLHdCQUFZLEdBQUcsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQzVCLHFCQUFTLEdBQUcsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDO1dBQzFCOzs7QUFHRCxjQUFJLG9CQUFFLFdBQVcsQ0FBQyxTQUFTLENBQUMsRUFBRTtBQUM1QixxQkFBUyxHQUFHLElBQUksQ0FBQztXQUNsQjs7O0FBR0QsY0FBSSxJQUFJLENBQUMsT0FBTyxLQUFLLGVBQWUsRUFBRTtBQUNwQyxlQUFHLENBQUMsS0FBSyx5QkFBdUIsb0JBQUUsS0FBSyxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsU0FBUyxDQUFDLEVBQUUsY0FBYyxDQUFDLENBQUcsQ0FBQztBQUN0RixlQUFHLENBQUMsS0FBSyxDQUFDLHdDQUF3QyxDQUFDLENBQUM7QUFDcEQscUJBQVMsR0FBRyxJQUFJLENBQUM7V0FDbEI7OztBQUdELHFCQUFXLENBQUMsTUFBTSxHQUFHLDBCQUEwQixDQUFDO0FBQ2hELHFCQUFXLENBQUMsS0FBSyxHQUFHLFNBQVMsQ0FBQztBQUM5QixhQUFHLENBQUMsSUFBSSxDQUFDLHNDQUFvQyxJQUFJLENBQUMsT0FBTyx5QkFDckMsb0JBQUUsS0FBSyxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsU0FBUyxDQUFDLEVBQUUsY0FBYyxDQUFDLENBQUUsQ0FBQyxDQUFDOzs7Ozs7O0FBRXRFLG1CQUFTOztBQUNiLGNBQUksRUFBRSw4REFBOEIsSUFDOUIseUNBQWlCLGVBQU8sa0JBQWtCLENBQUMsQ0FBQSxBQUFDLEVBQUU7QUFDbEQsZUFBRyxDQUFDLEtBQUssa0RBQWdELGVBQUksS0FBSyxDQUFHLENBQUM7QUFDdEUscUJBQVMsR0FBRyxJQUFJLGVBQU8sWUFBWSxnQkFBSyxDQUFDO1dBQzFDOzs7dUNBRzJCLHlCQUF5QixDQUFDLFNBQVMsQ0FBQzs7QUFBL0Qsb0JBQVU7QUFBRSxxQkFBVzs7Ozs7QUFJMUIsY0FBSSxvQkFBRSxRQUFRLENBQUMsV0FBVyxDQUFDLEVBQUU7QUFDM0IsZUFBRyxDQUFDLE1BQU0sQ0FBQyxVQUFVLENBQUMsQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLENBQUM7V0FDMUMsTUFBTTtBQUNMLGdCQUFJLFlBQVksRUFBRTtBQUNoQix5QkFBVyxDQUFDLFNBQVMsR0FBRyxZQUFZLENBQUM7YUFDdEMsTUFBTTtBQUNMLHlCQUFXLENBQUMsU0FBUyxHQUFHLEdBQUcsQ0FBQyxNQUFNLENBQUMsU0FBUyxJQUFJLElBQUksQ0FBQzthQUN0RDs7QUFFRCxlQUFHLENBQUMsTUFBTSxDQUFDLFVBQVUsQ0FBQyxDQUFDLElBQUksQ0FBQyxXQUFXLENBQUMsQ0FBQztXQUMxQzs7Ozs7OztHQUNGLENBQUM7O0FBRUYsS0FBRyxDQUFDLE1BQU0sQ0FBQyxXQUFXLEVBQUUsQ0FBQyxDQUFDLElBQUksRUFBRSxVQUFDLEdBQUcsRUFBRSxHQUFHLEVBQUs7QUFDNUMsMEJBQUUsT0FBTyxDQUFDLFlBQVksQ0FBQyxHQUFHLEVBQUUsR0FBRyxDQUFDLENBQUMsQ0FBQyxJQUFJLEVBQUUsQ0FBQztHQUMxQyxDQUFDLENBQUM7Q0FDSjs7QUFFRCxTQUFTLHNCQUFzQixDQUFFLE1BQU0sRUFBRSxHQUFHLEVBQUUsT0FBTyxFQUFFOztBQUVyRCxNQUFJLENBQUMsTUFBTSxDQUFDLFdBQVcsQ0FBQyxHQUFHLENBQUMsTUFBTSxDQUFDLFNBQVMsQ0FBQyxFQUFFO0FBQzdDLFdBQU8sS0FBSyxDQUFDO0dBQ2Q7Ozs7QUFJRCxNQUFJLE9BQU8sS0FBSyxlQUFlLEVBQUU7QUFDL0IsV0FBTyxLQUFLLENBQUM7R0FDZDs7OztBQUlELE1BQUksY0FBYyxHQUFHLE1BQU0sQ0FBQyxpQkFBaUIsQ0FBQyxHQUFHLENBQUMsTUFBTSxDQUFDLFNBQVMsQ0FBQyxDQUFDOzs7Ozs7QUFDcEUsdUNBQXdCLGNBQWMsaUhBQUU7VUFBL0IsV0FBVzs7QUFDbEIsVUFBSSxDQUFDLG9CQUFFLE9BQU8sQ0FBQyxXQUFXLENBQUMsSUFBSSxXQUFXLENBQUMsTUFBTSxLQUFLLENBQUMsRUFBRTtBQUN2RCxjQUFNLElBQUksS0FBSyxDQUFDLHlDQUF5QyxDQUFDLENBQUM7T0FDNUQ7O3dDQUNtQyxXQUFXOztVQUExQyxXQUFXO1VBQUUsY0FBYzs7QUFDaEMsVUFBSSxDQUFDLG9CQUFFLFFBQVEsQ0FBQyxDQUFDLEtBQUssRUFBRSxNQUFNLEVBQUUsUUFBUSxDQUFDLEVBQUUsV0FBVyxDQUFDLEVBQUU7QUFDdkQsY0FBTSxJQUFJLEtBQUssNENBQXlDLFdBQVcsUUFBSSxDQUFDO09BQ3pFO0FBQ0QsVUFBSSxFQUFFLGNBQWMsWUFBWSxNQUFNLENBQUEsQUFBQyxFQUFFO0FBQ3ZDLGNBQU0sSUFBSSxLQUFLLENBQUMsbURBQW1ELENBQUMsQ0FBQztPQUN0RTtBQUNELFVBQUksYUFBYSxHQUFHLEdBQUcsQ0FBQyxXQUFXLENBQUMsT0FBTyxDQUFDLFlBQVksRUFBRSxFQUFFLENBQUMsQ0FBQztBQUM5RCxVQUFJLFdBQVcsS0FBSyxHQUFHLENBQUMsTUFBTSxJQUFJLGNBQWMsQ0FBQyxJQUFJLENBQUMsYUFBYSxDQUFDLEVBQUU7QUFDcEUsZUFBTyxLQUFLLENBQUM7T0FDZDtLQUNGOzs7Ozs7Ozs7Ozs7Ozs7O0FBRUQsU0FBTyxJQUFJLENBQUM7Q0FDYjs7QUFFRCxTQUFlLFVBQVUsQ0FBRSxNQUFNLEVBQUUsR0FBRyxFQUFFLEdBQUc7Ozs7QUFDekMsV0FBRyxDQUFDLElBQUksQ0FBQyx3REFBd0QsQ0FBQyxDQUFDOzs7O1lBRzlELE1BQU0sQ0FBQyxRQUFRLENBQUMsR0FBRyxDQUFDLE1BQU0sQ0FBQyxTQUFTLENBQUM7Ozs7O2NBQ2xDLElBQUksS0FBSyxDQUFDLGtFQUFrRSxDQUFDOzs7Ozt5Q0FHN0UsTUFBTSxDQUFDLGNBQWMsQ0FBQyxhQUFhLEVBQUUsR0FBRyxFQUFFLEdBQUcsRUFBRSxHQUFHLENBQUMsTUFBTSxDQUFDLFNBQVMsQ0FBQzs7Ozs7Ozs7O2NBRXBFLElBQUksS0FBSyxvQ0FBa0MsZUFBSSxPQUFPLENBQUc7Ozs7Ozs7Q0FFbEU7O1FBR1EsT0FBTyxHQUFQLE9BQU87UUFBRSx3QkFBd0IsR0FBeEIsd0JBQXdCO1FBQUUsZ0JBQWdCLEdBQWhCLGdCQUFnQiIsImZpbGUiOiJsaWIvbWpzb253cC5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBfIGZyb20gJ2xvZGFzaCc7XG5pbXBvcnQgeyBnZXRMb2dnZXIgfSBmcm9tICdhcHBpdW0tbG9nZ2VyJztcbmltcG9ydCB7IHZhbGlkYXRvcnMgfSBmcm9tICcuL3ZhbGlkYXRvcnMnO1xuaW1wb3J0IHsgZXJyb3JzLCBpc0Vycm9yVHlwZSwgTUpTT05XUEVycm9yIH0gZnJvbSAnLi9lcnJvcnMnO1xuaW1wb3J0IHsgTUVUSE9EX01BUCwgTk9fU0VTU0lPTl9JRF9DT01NQU5EUyB9IGZyb20gJy4vcm91dGVzJztcbmltcG9ydCBCIGZyb20gJ2JsdWViaXJkJztcblxuXG5jb25zdCBsb2cgPSBnZXRMb2dnZXIoJ01KU09OV1AnKTtcbmNvbnN0IEpTT05XUF9TVUNDRVNTX1NUQVRVU19DT0RFID0gMDtcbmNvbnN0IExPR19PQkpfTEVOR1RIID0gMTUwO1xuXG5jbGFzcyBNSlNPTldQIHt9XG5cbmZ1bmN0aW9uIGlzU2Vzc2lvbkNvbW1hbmQgKGNvbW1hbmQpIHtcbiAgcmV0dXJuICFfLmNvbnRhaW5zKE5PX1NFU1NJT05fSURfQ09NTUFORFMsIGNvbW1hbmQpO1xufVxuXG5mdW5jdGlvbiB3cmFwUGFyYW1zIChwYXJhbVNldHMsIGpzb25PYmopIHtcbiAgLyogVGhlcmUgYXJlIGNvbW1hbmRzIGxpa2UgcGVyZm9ybVRvdWNoIHdoaWNoIHRha2UgYSBzaW5nbGUgcGFyYW1ldGVyIChwcmltaXRpdmUgdHlwZSBvciBhcnJheSkuXG4gICAqIFNvbWUgZHJpdmVycyBjaG9vc2UgdG8gcGFzcyB0aGlzIHBhcmFtZXRlciBhcyBhIHZhbHVlIChlZy4gW2FjdGlvbjEsIGFjdGlvbjIuLi5dKSB3aGlsZSBvdGhlcnMgdG9cbiAgICogd3JhcCBpdCB3aXRoaW4gYW4gb2JqZWN0KGVnJyB7Z2VzdHVyZTogIFthY3Rpb24xLCBhY3Rpb24yLi4uXX0pLCB3aGljaCBtYWtlcyBpdCBoYXJkIHRvIHZhbGlkYXRlLlxuICAgKiBUaGUgd3JhcCBvcHRpb24gaW4gdGhlIHNwZWMgZW5mb3JjZSB3cmFwcGluZyBiZWZvcmUgdmFsaWRhdGlvbiwgc28gdGhhdCBhbGwgcGFyYW1zIGFyZSB3cmFwcGVkIGF0XG4gICAqIHRoZSB0aW1lIHRoZXkgYXJlIHZhbGlkYXRlZCBhbmQgbGF0ZXIgcGFzc2VkIHRvIHRoZSBjb21tYW5kcy5cbiAgICovXG4gIGxldCByZXMgPSBqc29uT2JqO1xuICBpZiAoXy5pc0FycmF5KGpzb25PYmopIHx8ICFfLmlzT2JqZWN0KGpzb25PYmopKSB7XG4gICAgcmVzID0ge307XG4gICAgcmVzW3BhcmFtU2V0cy53cmFwXSA9IGpzb25PYmo7XG4gIH1cbiAgcmV0dXJuIHJlcztcbn1cblxuZnVuY3Rpb24gdW53cmFwUGFyYW1zIChwYXJhbVNldHMsIGpzb25PYmopIHtcbiAgLyogVGhlcmUgYXJlIGNvbW1hbmRzIGxpa2Ugc2V0TmV0d29ya0Nvbm5lY3Rpb24gd2hpY2ggc2VuZCBwYXJhbWV0ZXJzIHdyYXBwZWQgaW5zaWRlIGEga2V5IHN1Y2ggYXNcbiAgICogXCJwYXJhbWV0ZXJzXCIuIFRoaXMgZnVuY3Rpb24gdW53cmFwcyB0aGVtIChlZy4ge1wicGFyYW1ldGVyc1wiOiB7XCJ0eXBlXCI6IDF9fSBiZWNvbWVzIHtcInR5cGVcIjogMX0pLlxuICAgKi9cbiAgbGV0IHJlcyA9IGpzb25PYmo7XG4gIGlmIChfLmlzT2JqZWN0KGpzb25PYmopKSB7XG4gICAgLy8gc29tZSBjbGllbnRzLCBsaWtlIHJ1YnksIGRvbid0IHdyYXBcbiAgICBpZiAoanNvbk9ialtwYXJhbVNldHMudW53cmFwXSkge1xuICAgICAgcmVzID0ganNvbk9ialtwYXJhbVNldHMudW53cmFwXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlcztcbn1cblxuZnVuY3Rpb24gY2hlY2tQYXJhbXMgKHBhcmFtU2V0cywganNvbk9iaikge1xuICBsZXQgcmVxdWlyZWRQYXJhbXMgPSBbXTtcbiAgbGV0IG9wdGlvbmFsUGFyYW1zID0gW107XG4gIGxldCByZWNlaXZlZFBhcmFtcyA9IF8ua2V5cyhqc29uT2JqKTtcblxuICBpZiAocGFyYW1TZXRzKSB7XG4gICAgaWYgKHBhcmFtU2V0cy5yZXF1aXJlZCkge1xuICAgICAgLy8gd2UgbWlnaHQgaGF2ZSBhbiBhcnJheSBvZiBwYXJhbWV0ZXJzLFxuICAgICAgLy8gb3IgYW4gYXJyYXkgb2YgYXJyYXlzIG9mIHBhcmFtZXRlcnMsIHNvIHN0YW5kYXJkaXplXG4gICAgICBpZiAoIV8uaXNBcnJheShfLmZpcnN0KHBhcmFtU2V0cy5yZXF1aXJlZCkpKSB7XG4gICAgICAgIHJlcXVpcmVkUGFyYW1zID0gW3BhcmFtU2V0cy5yZXF1aXJlZF07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXF1aXJlZFBhcmFtcyA9IHBhcmFtU2V0cy5yZXF1aXJlZDtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gb3B0aW9uYWwgcGFyYW1ldGVycyBhcmUganVzdCBhbiBhcnJheVxuICAgIGlmIChwYXJhbVNldHMub3B0aW9uYWwpIHtcbiAgICAgIG9wdGlvbmFsUGFyYW1zID0gcGFyYW1TZXRzLm9wdGlvbmFsO1xuICAgIH1cbiAgfVxuXG4gIC8vIGlmIHdlIGhhdmUgbm8gcmVxdWlyZWQgcGFyYW1ldGVycywgYWxsIGlzIHdlbGxcbiAgaWYgKHJlcXVpcmVkUGFyYW1zLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIHNvbWUgY2xpZW50cyBwYXNzIGluIHRoZSBzZXNzaW9uIGlkIGluIHRoZSBwYXJhbXNcbiAgb3B0aW9uYWxQYXJhbXMucHVzaCgnc2Vzc2lvbklkJyk7XG5cbiAgLy8gc29tZSBjbGllbnRzIHBhc3MgaW4gYW4gZWxlbWVudCBpZCBpbiB0aGUgcGFyYW1zXG4gIG9wdGlvbmFsUGFyYW1zLnB1c2goJ2lkJyk7XG5cbiAgLy8gZ28gdGhyb3VnaCB0aGUgcmVxdWlyZWQgcGFyYW1ldGVycyBhbmQgY2hlY2sgYWdhaW5zdCBvdXIgYXJndW1lbnRzXG4gIGZvciAobGV0IHBhcmFtcyBvZiByZXF1aXJlZFBhcmFtcykge1xuICAgIGlmIChfLmRpZmZlcmVuY2UocmVjZWl2ZWRQYXJhbXMsIHBhcmFtcywgb3B0aW9uYWxQYXJhbXMpLmxlbmd0aCA9PT0gMCAmJlxuICAgICAgICBfLmRpZmZlcmVuY2UocGFyYW1zLCByZWNlaXZlZFBhcmFtcykubGVuZ3RoID09PSAwKSB7XG4gICAgICAvLyB3ZSBoYXZlIGEgc2V0IG9mIHBhcmFtZXRlcnMgdGhhdCBpcyBjb3JyZWN0XG4gICAgICAvLyBzbyBzaG9ydC1jaXJjdWl0XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9XG4gIHRocm93IG5ldyBlcnJvcnMuQmFkUGFyYW1ldGVyc0Vycm9yKHBhcmFtU2V0cywgcmVjZWl2ZWRQYXJhbXMpO1xufVxuXG5mdW5jdGlvbiBtYWtlQXJncyAocmVxUGFyYW1zLCBqc29uT2JqLCBwYXlsb2FkUGFyYW1zKSB7XG4gIC8vIHdlIHdhbnQgdG8gcGFzcyB0aGUgdXJsIHBhcmFtZXRlcnMgdG8gdGhlIGNvbW1hbmRzIGluIHJldmVyc2Ugb3JkZXJcbiAgLy8gc2luY2UgdGhlIGNvbW1hbmQgd2lsbCBzb21ldGltZXMgd2FudCB0byBpZ25vcmUsIHNheSwgdGhlIHNlc3Npb25JZFxuICBsZXQgdXJsUGFyYW1zID0gXy5rZXlzKHJlcVBhcmFtcykucmV2ZXJzZSgpO1xuXG4gIC8vIHRoZXJlIGNhbiBiZSBtdWx0aXBsZSBzZXRzIG9mIHJlcXVpcmVkIHBhcmFtcywgc28gZmluZCB0aGUgY29ycmVjdCBvbmVcbiAgbGV0IHJlYWxSZXF1aXJlZFBhcmFtcyA9IHBheWxvYWRQYXJhbXMucmVxdWlyZWQ7XG4gIGlmIChfLmlzQXJyYXkoXy5maXJzdChwYXlsb2FkUGFyYW1zLnJlcXVpcmVkKSkpIHtcbiAgICBsZXQga2V5cyA9IF8ua2V5cyhqc29uT2JqKTtcbiAgICBmb3IgKGxldCBwYXJhbXMgb2YgcGF5bG9hZFBhcmFtcy5yZXF1aXJlZCkge1xuICAgICAgLy8gY2hlY2sgaWYgYWxsIHRoZSByZXF1aXJlZCBwYXJhbWV0ZXJzIGFyZSBpbiB0aGUganNvbiBvYmplY3RcbiAgICAgIGlmIChfLndpdGhvdXQocGFyYW1zLCAuLi5rZXlzKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgLy8gd2UgaGF2ZSBhbGwgdGhlIHBhcmFtZXRlcnMgZm9yIHRoaXMgc2V0XG4gICAgICAgIHJlYWxSZXF1aXJlZFBhcmFtcyA9IHBhcmFtcztcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGxldCBhcmdzID0gXy5mbGF0dGVuKHJlYWxSZXF1aXJlZFBhcmFtcykubWFwKHAgPT4ganNvbk9ialtwXSk7XG5cbiAgaWYgKHBheWxvYWRQYXJhbXMub3B0aW9uYWwpIHtcbiAgICBhcmdzID0gYXJncy5jb25jYXQoXy5mbGF0dGVuKHBheWxvYWRQYXJhbXMub3B0aW9uYWwpLm1hcChwID0+IGpzb25PYmpbcF0pKTtcbiAgfVxuICBhcmdzID0gYXJncy5jb25jYXQodXJsUGFyYW1zLm1hcCh1ID0+IHJlcVBhcmFtc1t1XSkpO1xuICByZXR1cm4gYXJncztcbn1cblxuZnVuY3Rpb24gZ2V0UmVzcG9uc2VGb3JKc29ud3BFcnJvciAoZXJyKSB7XG4gIGxldCBodHRwU3RhdHVzID0gNTAwO1xuICBsZXQgaHR0cFJlc0JvZHkgPSB7XG4gICAgc3RhdHVzOiBlcnIuanNvbndwQ29kZSxcbiAgICB2YWx1ZToge1xuICAgICAgbWVzc2FnZTogZXJyLm1lc3NhZ2VcbiAgICB9XG4gIH07XG5cbiAgaWYgKGlzRXJyb3JUeXBlKGVyciwgZXJyb3JzLkJhZFBhcmFtZXRlcnNFcnJvcikpIHtcbiAgICAvLyByZXNwb25kIHdpdGggYSA0MDAgaWYgd2UgaGF2ZSBiYWQgcGFyYW1ldGVyc1xuICAgIGxvZy5kZWJ1ZyhgQmFkIHBhcmFtZXRlcnM6ICR7ZXJyfWApO1xuICAgIGh0dHBTdGF0dXMgPSA0MDA7XG4gICAgaHR0cFJlc0JvZHkgPSBlcnIubWVzc2FnZTtcbiAgfSBlbHNlIGlmIChpc0Vycm9yVHlwZShlcnIsIGVycm9ycy5Ob3RZZXRJbXBsZW1lbnRlZEVycm9yKSB8fFxuICAgICAgICAgICAgIGlzRXJyb3JUeXBlKGVyciwgZXJyb3JzLk5vdEltcGxlbWVudGVkRXJyb3IpKSB7XG4gICAgLy8gcmVzcG9uZCB3aXRoIGEgNTAxIGlmIHRoZSBtZXRob2QgaXMgbm90IGltcGxlbWVudGVkXG4gICAgaHR0cFN0YXR1cyA9IDUwMTtcbiAgfSBlbHNlIGlmIChpc0Vycm9yVHlwZShlcnIsIGVycm9ycy5Ob1N1Y2hEcml2ZXJFcnJvcikpIHtcbiAgICAvLyByZXNwb25kIHdpdGggYSA0MDQgaWYgdGhlcmUgaXMgbm8gZHJpdmVyIGZvciB0aGUgc2Vzc2lvblxuICAgIGh0dHBTdGF0dXMgPSA0MDQ7XG4gIH1cblxuXG4gIHJldHVybiBbaHR0cFN0YXR1cywgaHR0cFJlc0JvZHldO1xufVxuXG5mdW5jdGlvbiByb3V0ZUNvbmZpZ3VyaW5nRnVuY3Rpb24gKGRyaXZlcikge1xuICBpZiAoIWRyaXZlci5zZXNzaW9uRXhpc3RzKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdEcml2ZXJzIHVzZWQgd2l0aCBNSlNPTldQIG11c3QgaW1wbGVtZW50IGBzZXNzaW9uRXhpc3RzYCcpO1xuICB9XG5cbiAgaWYgKCEoZHJpdmVyLmV4ZWN1dGVDb21tYW5kIHx8IGRyaXZlci5leGVjdXRlKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignRHJpdmVycyB1c2VkIHdpdGggTUpTT05XUCBtdXN0IGltcGxlbWVudCBgZXhlY3V0ZUNvbW1hbmRgIG9yIGBleGVjdXRlYCcpO1xuICB9XG5cbiAgLy8gcmV0dXJuIGEgZnVuY3Rpb24gd2hpY2ggd2lsbCBhZGQgYWxsIHRoZSByb3V0ZXMgdG8gdGhlIGRyaXZlclxuICByZXR1cm4gZnVuY3Rpb24gKGFwcCkge1xuICAgIGZvciAobGV0IFtwYXRoLCBtZXRob2RzXSBvZiBfLnBhaXJzKE1FVEhPRF9NQVApKSB7XG4gICAgICBmb3IgKGxldCBbbWV0aG9kLCBzcGVjXSBvZiBfLnBhaXJzKG1ldGhvZHMpKSB7XG4gICAgICAgIGxldCBpc1Nlc3NDbWQgPSBpc1Nlc3Npb25Db21tYW5kKHNwZWMuY29tbWFuZCk7XG5cbiAgICAgICAgLy8gc2V0IHVwIHRoZSBleHByZXNzIHJvdXRlIGhhbmRsZXJcbiAgICAgICAgYnVpbGRIYW5kbGVyKGFwcCwgbWV0aG9kLCBwYXRoLCBzcGVjLCBkcml2ZXIsIGlzU2Vzc0NtZCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiBidWlsZEhhbmRsZXIgKGFwcCwgbWV0aG9kLCBwYXRoLCBzcGVjLCBkcml2ZXIsIGlzU2Vzc0NtZCkge1xuICBsZXQgYXN5bmNIYW5kbGVyID0gYXN5bmMgKHJlcSwgcmVzKSA9PiB7XG4gICAgbGV0IGpzb25PYmogPSByZXEuYm9keTtcbiAgICBsZXQgaHR0cFJlc0JvZHkgPSB7fTtcbiAgICBsZXQgaHR0cFN0YXR1cyA9IDIwMDtcbiAgICBsZXQgbmV3U2Vzc2lvbklkO1xuICAgIHRyeSB7XG4gICAgICAvLyBpZiB0aGlzIGlzIGEgc2Vzc2lvbiBjb21tYW5kIGJ1dCB3ZSBkb24ndCBoYXZlIGEgc2Vzc2lvbixcbiAgICAgIC8vIGVycm9yIG91dCBlYXJseSAoZXNwZWNpYWxseSBiZWZvcmUgcHJveHlpbmcpXG4gICAgICBpZiAoaXNTZXNzQ21kICYmICFkcml2ZXIuc2Vzc2lvbkV4aXN0cyhyZXEucGFyYW1zLnNlc3Npb25JZCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IGVycm9ycy5Ob1N1Y2hEcml2ZXJFcnJvcigpO1xuICAgICAgfVxuXG4gICAgICAvLyBpZiB0aGUgZHJpdmVyIGlzIGN1cnJlbnRseSBwcm94eWluZyBjb21tYW5kcyB0byBhbm90aGVyIEpTT05XUFxuICAgICAgLy8gc2VydmVyLCBieXBhc3MgYWxsIG91ciBjaGVja3MgYW5kIGFzc3VtZSB0aGUgdXBzdHJlYW0gc2VydmVyIGtub3dzXG4gICAgICAvLyB3aGF0IGl0J3MgZG9pbmcuIEJ1dCBrZWVwIHRoaXMgaW4gdGhlIHRyeS9jYXRjaCBibG9jayBzbyBpZiBwcm94eWluZ1xuICAgICAgLy8gaXRzZWxmIGZhaWxzLCB3ZSBnaXZlIGEgbWVzc2FnZSB0byB0aGUgY2xpZW50LiBPZiBjb3Vyc2Ugd2Ugb25seVxuICAgICAgLy8gd2FudCB0byBkbyB0aGVzZSB3aGVuIHdlIGhhdmUgYSBzZXNzaW9uIGNvbW1hbmQ7IHRoZSBBcHBpdW0gZHJpdmVyXG4gICAgICAvLyBtdXN0IGJlIHJlc3BvbnNpYmxlIGZvciBzdGFydC9zdG9wIHNlc3Npb24sIGV0Yy4uLlxuICAgICAgaWYgKGlzU2Vzc0NtZCAmJiBkcml2ZXJTaG91bGREb0p3cFByb3h5KGRyaXZlciwgcmVxLCBzcGVjLmNvbW1hbmQpKSB7XG4gICAgICAgIGF3YWl0IGRvSndwUHJveHkoZHJpdmVyLCByZXEsIHJlcyk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gaWYgYSBjb21tYW5kIGlzIG5vdCBpbiBvdXIgbWV0aG9kIG1hcCwgaXQncyBiZWNhdXNlIHdlXG4gICAgICAvLyBoYXZlIG5vIHBsYW5zIHRvIGV2ZXIgaW1wbGVtZW50IGl0XG4gICAgICBpZiAoIXNwZWMuY29tbWFuZCkge1xuICAgICAgICB0aHJvdyBuZXcgZXJyb3JzLk5vdEltcGxlbWVudGVkRXJyb3IoKTtcbiAgICAgIH1cblxuICAgICAgLy8gd3JhcCBwYXJhbXMgaWYgbmVjZXNzYXJ5XG4gICAgICBpZiAoc3BlYy5wYXlsb2FkUGFyYW1zICYmIHNwZWMucGF5bG9hZFBhcmFtcy53cmFwKSB7XG4gICAgICAgIGpzb25PYmogPSB3cmFwUGFyYW1zKHNwZWMucGF5bG9hZFBhcmFtcywganNvbk9iaik7XG4gICAgICB9XG5cbiAgICAgIC8vIHVud3JhcCBwYXJhbXMgaWYgbmVjZXNzYXJ5XG4gICAgICBpZiAoc3BlYy5wYXlsb2FkUGFyYW1zICYmIHNwZWMucGF5bG9hZFBhcmFtcy51bndyYXApIHtcbiAgICAgICAganNvbk9iaiA9IHVud3JhcFBhcmFtcyhzcGVjLnBheWxvYWRQYXJhbXMsIGpzb25PYmopO1xuICAgICAgfVxuXG4gICAgICAvLyBlbnN1cmUgdGhhdCB0aGUganNvbiBwYXlsb2FkIGNvbmZvcm1zIHRvIHRoZSBzcGVjXG4gICAgICBjaGVja1BhcmFtcyhzcGVjLnBheWxvYWRQYXJhbXMsIGpzb25PYmopO1xuICAgICAgLy8gZW5zdXJlIHRoZSBzZXNzaW9uIHRoZSB1c2VyIGlzIHRyeWluZyB0byB1c2UgaXMgdmFsaWRcblxuICAgICAgLy8gdHVybiB0aGUgY29tbWFuZCBhbmQganNvbiBwYXlsb2FkIGludG8gYW4gYXJndW1lbnQgbGlzdCBmb3JcbiAgICAgIC8vIHRoZSBkcml2ZXIgbWV0aG9kc1xuICAgICAgbGV0IGFyZ3MgPSBtYWtlQXJncyhyZXEucGFyYW1zLCBqc29uT2JqLCBzcGVjLnBheWxvYWRQYXJhbXMgfHwgW10pO1xuICAgICAgbGV0IGRyaXZlclJlcztcbiAgICAgIC8vIHZhbGlkYXRlIGNvbW1hbmQgYXJncyBhY2NvcmRpbmcgdG8gTUpTT05XUFxuICAgICAgaWYgKHZhbGlkYXRvcnNbc3BlYy5jb21tYW5kXSkge1xuICAgICAgICB2YWxpZGF0b3JzW3NwZWMuY29tbWFuZF0oLi4uYXJncyk7XG4gICAgICB9XG4gICAgICAvLyBydW4gdGhlIGRyaXZlciBjb21tYW5kIHdyYXBwZWQgaW5zaWRlIHRoZSBhcmd1bWVudCB2YWxpZGF0b3JzXG4gICAgICBsb2cuaW5mbyhgQ2FsbGluZyAke2RyaXZlci5jb25zdHJ1Y3Rvci5uYW1lfS4ke3NwZWMuY29tbWFuZH0oKSB3aXRoIGFyZ3M6IGAgK1xuICAgICAgICAgICAgICAgIF8udHJ1bmMoSlNPTi5zdHJpbmdpZnkoYXJncyksIExPR19PQkpfTEVOR1RIKSk7XG5cbiAgICAgIGlmIChkcml2ZXIuZXhlY3V0ZUNvbW1hbmQpIHtcbiAgICAgICAgZHJpdmVyUmVzID0gYXdhaXQgZHJpdmVyLmV4ZWN1dGVDb21tYW5kKHNwZWMuY29tbWFuZCwgLi4uYXJncyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkcml2ZXJSZXMgPSBhd2FpdCBkcml2ZXIuZXhlY3V0ZShzcGVjLmNvbW1hbmQsIC4uLmFyZ3MpO1xuICAgICAgfVxuXG4gICAgICAvLyB1bnBhY2sgY3JlYXRlU2Vzc2lvbiByZXNwb25zZVxuICAgICAgaWYgKHNwZWMuY29tbWFuZCA9PT0gJ2NyZWF0ZVNlc3Npb24nKSB7XG4gICAgICAgIG5ld1Nlc3Npb25JZCA9IGRyaXZlclJlc1swXTtcbiAgICAgICAgZHJpdmVyUmVzID0gZHJpdmVyUmVzWzFdO1xuICAgICAgfVxuXG4gICAgICAvLyBjb252ZXJ0IHVuZGVmaW5lZCB0byBudWxsLCBidXQgbGVhdmUgYWxsIG90aGVyIHZhbHVlcyB0aGUgc2FtZVxuICAgICAgaWYgKF8uaXNVbmRlZmluZWQoZHJpdmVyUmVzKSkge1xuICAgICAgICBkcml2ZXJSZXMgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICAvLyBkZWxldGUgc2hvdWxkIG5vdCByZXR1cm4gYW55dGhpbmcgZXZlbiBpZiBzdWNjZXNzZnVsXG4gICAgICBpZiAoc3BlYy5jb21tYW5kID09PSAnZGVsZXRlU2Vzc2lvbicpIHtcbiAgICAgICAgbG9nLmRlYnVnKGBSZWNlaXZlZCByZXNwb25zZTogJHtfLnRydW5jKEpTT04uc3RyaW5naWZ5KGRyaXZlclJlcyksIExPR19PQkpfTEVOR1RIKX1gKTtcbiAgICAgICAgbG9nLmRlYnVnKCdCdXQgZGVsZXRpbmcgc2Vzc2lvbiwgc28gbm90IHJldHVybmluZycpO1xuICAgICAgICBkcml2ZXJSZXMgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICAvLyBhc3N1bWluZyBldmVyeXRoaW5nIHdvcmtlZCwgc2V0IHVwIHRoZSBqc29uIHJlc3BvbnNlIG9iamVjdFxuICAgICAgaHR0cFJlc0JvZHkuc3RhdHVzID0gSlNPTldQX1NVQ0NFU1NfU1RBVFVTX0NPREU7XG4gICAgICBodHRwUmVzQm9keS52YWx1ZSA9IGRyaXZlclJlcztcbiAgICAgIGxvZy5pbmZvKGBSZXNwb25kaW5nIHRvIGNsaWVudCB3aXRoIGRyaXZlci4ke3NwZWMuY29tbWFuZH0oKSBgICtcbiAgICAgICAgICAgICAgIGByZXN1bHQ6ICR7Xy50cnVuYyhKU09OLnN0cmluZ2lmeShkcml2ZXJSZXMpLCBMT0dfT0JKX0xFTkdUSCl9YCk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBsZXQgYWN0dWFsRXJyID0gZXJyO1xuICAgICAgaWYgKCEoaXNFcnJvclR5cGUoZXJyLCBNSlNPTldQRXJyb3IpIHx8XG4gICAgICAgICAgICBpc0Vycm9yVHlwZShlcnIsIGVycm9ycy5CYWRQYXJhbWV0ZXJzRXJyb3IpKSkge1xuICAgICAgICBsb2cuZXJyb3IoYEVuY291bnRlcmVkIGludGVybmFsIGVycm9yIHJ1bm5pbmcgY29tbWFuZDogJHtlcnIuc3RhY2t9YCk7XG4gICAgICAgIGFjdHVhbEVyciA9IG5ldyBlcnJvcnMuVW5rbm93bkVycm9yKGVycik7XG4gICAgICB9XG4gICAgICAvLyBpZiBhbnl0aGluZyBnb2VzIHdyb25nLCBmaWd1cmUgb3V0IHdoYXQgb3VyIHJlc3BvbnNlIHNob3VsZCBiZVxuICAgICAgLy8gYmFzZWQgb24gdGhlIHR5cGUgb2YgZXJyb3IgdGhhdCB3ZSBlbmNvdW50ZXJlZFxuICAgICAgW2h0dHBTdGF0dXMsIGh0dHBSZXNCb2R5XSA9IGdldFJlc3BvbnNlRm9ySnNvbndwRXJyb3IoYWN0dWFsRXJyKTtcbiAgICB9XG5cbiAgICAvLyBkZWNvZGUgdGhlIHJlc3BvbnNlLCB3aGljaCBpcyBlaXRoZXIgYSBzdHJpbmcgb3IganNvblxuICAgIGlmIChfLmlzU3RyaW5nKGh0dHBSZXNCb2R5KSkge1xuICAgICAgcmVzLnN0YXR1cyhodHRwU3RhdHVzKS5zZW5kKGh0dHBSZXNCb2R5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKG5ld1Nlc3Npb25JZCkge1xuICAgICAgICBodHRwUmVzQm9keS5zZXNzaW9uSWQgPSBuZXdTZXNzaW9uSWQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBodHRwUmVzQm9keS5zZXNzaW9uSWQgPSByZXEucGFyYW1zLnNlc3Npb25JZCB8fCBudWxsO1xuICAgICAgfVxuXG4gICAgICByZXMuc3RhdHVzKGh0dHBTdGF0dXMpLmpzb24oaHR0cFJlc0JvZHkpO1xuICAgIH1cbiAgfTtcbiAgLy8gYWRkIHRoZSBtZXRob2QgdG8gdGhlIGFwcFxuICBhcHBbbWV0aG9kLnRvTG93ZXJDYXNlKCldKHBhdGgsIChyZXEsIHJlcykgPT4ge1xuICAgIEIucmVzb2x2ZShhc3luY0hhbmRsZXIocmVxLCByZXMpKS5kb25lKCk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBkcml2ZXJTaG91bGREb0p3cFByb3h5IChkcml2ZXIsIHJlcSwgY29tbWFuZCkge1xuICAvLyBkcml2ZXJzIG5lZWQgdG8gZXhwbGljaXRseSBzYXkgd2hlbiB0aGUgcHJveHkgaXMgYWN0aXZlXG4gIGlmICghZHJpdmVyLnByb3h5QWN0aXZlKHJlcS5wYXJhbXMuc2Vzc2lvbklkKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8vIHdlIHNob3VsZCBuZXZlciBwcm94eSBkZWxldGVTZXNzaW9uIGJlY2F1c2Ugd2UgbmVlZCB0byBnaXZlIHRoZSBjb250YWluaW5nXG4gIC8vIGRyaXZlciBhbiBvcHBvcnR1bml0eSB0byBjbGVhbiBpdHNlbGYgdXBcbiAgaWYgKGNvbW1hbmQgPT09ICdkZWxldGVTZXNzaW9uJykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8vIHZhbGlkYXRlIGF2b2lkYW5jZSBzY2hlbWEsIGFuZCBzYXkgd2Ugc2hvdWxkbid0IHByb3h5IGlmIGFueXRoaW5nIGluIHRoZVxuICAvLyBhdm9pZCBsaXN0IG1hdGNoZXMgb3VyIHJlcVxuICBsZXQgcHJveHlBdm9pZExpc3QgPSBkcml2ZXIuZ2V0UHJveHlBdm9pZExpc3QocmVxLnBhcmFtcy5zZXNzaW9uSWQpO1xuICBmb3IgKGxldCBhdm9pZFNjaGVtYSBvZiBwcm94eUF2b2lkTGlzdCkge1xuICAgIGlmICghXy5pc0FycmF5KGF2b2lkU2NoZW1hKSB8fCBhdm9pZFNjaGVtYS5sZW5ndGggIT09IDIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignUHJveHkgYXZvaWRhbmNlIG11c3QgYmUgYSBsaXN0IG9mIHBhaXJzJyk7XG4gICAgfVxuICAgIGxldCBbYXZvaWRNZXRob2QsIGF2b2lkUGF0aFJlZ2V4XSA9IGF2b2lkU2NoZW1hO1xuICAgIGlmICghXy5jb250YWlucyhbJ0dFVCcsICdQT1NUJywgJ0RFTEVURSddLCBhdm9pZE1ldGhvZCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVW5yZWNvZ25pemVkIHByb3h5IGF2b2lkYW5jZSBtZXRob2QgJyR7YXZvaWRNZXRob2R9J2ApO1xuICAgIH1cbiAgICBpZiAoIShhdm9pZFBhdGhSZWdleCBpbnN0YW5jZW9mIFJlZ0V4cCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignUHJveHkgYXZvaWRhbmNlIHBhdGggbXVzdCBiZSBhIHJlZ3VsYXIgZXhwcmVzc2lvbicpO1xuICAgIH1cbiAgICBsZXQgbm9ybWFsaXplZFVybCA9IHJlcS5vcmlnaW5hbFVybC5yZXBsYWNlKC9eXFwvd2RcXC9odWIvLCAnJyk7XG4gICAgaWYgKGF2b2lkTWV0aG9kID09PSByZXEubWV0aG9kICYmIGF2b2lkUGF0aFJlZ2V4LnRlc3Qobm9ybWFsaXplZFVybCkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuYXN5bmMgZnVuY3Rpb24gZG9Kd3BQcm94eSAoZHJpdmVyLCByZXEsIHJlcykge1xuICBsb2cuaW5mbygnRHJpdmVyIHByb3h5IGFjdGl2ZSwgcGFzc2luZyByZXF1ZXN0IG9uIHZpYSBIVFRQIHByb3h5Jyk7XG5cbiAgLy8gY2hlY2sgdGhhdCB0aGUgaW5uZXIgZHJpdmVyIGhhcyBhIHByb3h5IGZ1bmN0aW9uXG4gIGlmICghZHJpdmVyLmNhblByb3h5KHJlcS5wYXJhbXMuc2Vzc2lvbklkKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignVHJ5aW5nIHRvIHByb3h5IHRvIGEgSlNPTldQIHNlcnZlciBidXQgZHJpdmVyIGlzIHVuYWJsZSB0byBwcm94eScpO1xuICB9XG4gIHRyeSB7XG4gICAgYXdhaXQgZHJpdmVyLmV4ZWN1dGVDb21tYW5kKCdwcm94eVJlcVJlcycsIHJlcSwgcmVzLCByZXEucGFyYW1zLnNlc3Npb25JZCk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHRocm93IG5ldyBFcnJvcihgQ291bGQgbm90IHByb3h5LiBQcm94eSBlcnJvcjogJHtlcnIubWVzc2FnZX1gKTtcbiAgfVxufVxuXG5cbmV4cG9ydCB7IE1KU09OV1AsIHJvdXRlQ29uZmlndXJpbmdGdW5jdGlvbiwgaXNTZXNzaW9uQ29tbWFuZCB9O1xuIl19